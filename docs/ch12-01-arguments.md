# コマンドライン引数

> Ref: https://doc.rust-jp.rs/book-ja/ch12-01-accepting-command-line-arguments.html

いつものように、`cargo new minigrep`を実行してプロジェクトを作成しましょう。

はじめにすることは、`minigrep`に2つの引数を受け付けるようにすることです。
つまり、`cargo run`で検索文字列と検索を行うファイルへのパスと共にプログラムを実行できるようにします。

```bash
cargo run searchstring example-filename.txt
```

現在のプログラムでは、与えられた引数を処理できません。Crates.ioにある既存のライブラリを使っても良いですが、ここでは自身の手で実装していきます。

## 引数の値を読み取る

`minigrep`が渡したコマンドライン引数の値を読み取れるようにするために、Rustの標準ライブラリで提供されている`std::env::args`を使用します。
これは、`minigrep`に与えられたコマンドライン引数のイテレータを返します。 イテレータに関しては第13章で説明します。
ここではイテレータは一連の値を生成することと、`collect`関数を呼び出してイテレータが生成する要素すべてを含むベクターなどのコレクションに変えられることを覚えておいてください。

```rust
use std::env;

fn main() {
    let args: Vec<String> = env::args().collect();
    println!("{:?}", args);
}
```

ここでは、`std::env`モジュールをスコープに導入し、`args`関数を使用可能にします。
なぜ`std::env::args`をスコープに導入しないのか考えてみてください。
もしこのように書いてもコードは動作はしますが、`args`は現在のモジュールに定義されている関数と見間違えるかもしれないので、紛らわしいです。
スコープに導入するモジュールで他の変数や関数名にかぶるような物は入れないでおきましょう。

> **`args`関数と不正なユニコード**
>
> 引数のどれかが不正なユニコードを含む場合、`std::env::args`はパニックになります。
> 不正なユニコードを含む引数を受け付ける必要がある場合は、`std::env::args_os`を使用します。
> この関数は、`String`値ではなく、`OsString`値を生成するイテレータを返します。
> なぜなら、`OsString`値はプラットフォームごとに異なり、`String`あたいに比べて取り扱いが煩雑だからです。

次に、`collect`を使用して、イテレータをイテレータが生成する値すべてを含むベクターに変換します。
`collect`関数を使用して多くの種類のコレクションを生成することができるので、`args`の型を明示的に注釈して文字列のベクターが欲しいのだと指定しています。
Rustにおいて、型注釈しなければならない頻度は非常に少ないですが、`collect`はよく注釈を必要とする関数の1つです。
コンパイラは、あなたが欲しているコレクションの種類が推論できないからです。

ではプログラムを走らせてみましょう。

```bash
cargo run
--snip--
["target/debug/minigrep"]

cargo run needle haystack
--snip--
["target/debug/minigrep", "needle", "haystack"]
```

ベクターの最初の値は、`"target/debug/minigrep"`で、バイナリの名前です。
これはCの引数リストの振る舞いと合致し、実行時に呼び出された名前をプログラムに使わせてくれるわけです。
メッセージを出力したり、プログラムを起動するのに使用されたコマンドラインエイリアスによってプログラムの振る舞いを変えたい場合に、プログラム名にアクセするのに便利です。
この章では、バイナリ名は無視し、必要な2つの引数のみを保存します。

## 引数の値を保存する

引数のベクター値を出力すると、プログラムはコマンドライン引数として指定された値にアクセスできます。
次に、2つの引数の値を変数に保存するようにプログラムを書きます。

```rust
use std::env;

fn main() {
    let args: Vec<String> = env::args().collect();

    let query = &args[1];
    let filename = &args[2];

    println!("Searching for {}", query);
    println!("In file {}", filename);
}
```

`args[0]`は常にバイナリ名が入るので、`args[1]`から読み取ります。

ではプログラムを実行して、意図した動きになっているか確認してみましょう。

```bash
cargo run
--snip--
Searching for test
In file sample.txt
```

プログラムは動作します。がまだ問題は残っています。
あとは、何らかのエラー処理を加えてユーザーが引数を提供しなかった場合など、可能性のある特定のエラー状況に対処します。
今はそのような状況はないものとして、次節ではファイル読み取りする方法を見ていきます。
