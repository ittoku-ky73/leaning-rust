# SyncとSendトレイト

> Ref: https://doc.rust-jp.rs/book-ja/ch16-04-extensible-concurrency-sync-and-send.html

Rust言語には寡少な並行性機能があります。
今までこの章で説明してきた並行性機能のほとんどは標準ライブラリの一部です。
並行性を扱う選択肢は、言語や標準ライブラリに限った話ではないということです。

この章で最後に紹介する並行性概念は`std::marker`トレイトにある`Sync, Send`です。

### Sendマーカートレイト

`Send`マーカートレイトとは、実装した型に、型の所有権をスレッド間で転送できることを示唆します。
Rustのほとんどの型は`Send`ですが、`Rc<T>`を含む例外もあります。
`Rc<T>`は値をクローンし、クローンした値の所有権を別スレッドに転送できてしまうと、両方のスレッドが同時に参照カウントを更新してしまうため`Send`にならないです。
そのため`Rc<T>`はスレッド安全性のためのパフォーマンスの犠牲を払わなくて済み、シングルスレッド環境で使用するために実装されているわけです。

そのため`Rc<T>`はRustの型システムとトレイト境界により値が安全ではない状態でスレッドに送信することが内容保証してくれるのです。

### Syncマーカートレイト

`Sync`マーカートレイトとは、実装した型に、複数のスレッドから参照されても安全であることを示唆します。

また、スマートポインタである`Rc<T>`もまた`Sync`ではありません。`RefCell<T>`型と関連する`Cell<T>`系についても`Sync`ではありません。
`RefCell<T>`が実行時に行う借用チェックの実装はスレッドセーフではありません。
スマートポインタの`Mutex<T>`は`Sync`で、前節でみたように複数のスレッドでアクセスを共有するのに使用することができます。

### 手動実装は非安全

`Send, Sync`トレイトから構成される型は自動的に`Send, Sync`になるので、手動で実装する必要はありません。

これらのトレイトを手動で実装することはunsafeなRustコードを実装することになります。
unsafeなRustコードについては第19章で説明しますが、`Send, Sync`ではない新しい並行な型を構成するには、安全性補償を保持するために、注意深い思考が必要になるということです。

### まとめ

並行性については再度、第20章のプロジェクトで見ることになります。

Rustによる並行性の取り扱いのごく一部のみが言語使用なので、多くの平衡性の解決策はクレートとして実装されています。
クレートは標準ライブラリよりも迅速に進化するので、マルチスレッド環境で使用すべき現在の最先端のクレートを調べる必要があります。

Rustの標準ライブラリは、メッセージ受け渡しにチャンネルを並行の文脈で安全に使用できる`Mutex<T>, Arc<T>`などのスマートポインタ型を提供しています。
型システムと借用チェッカーにより、コードがデータ競合や無効な参照を行わないようになっています。
つまり一度コンパイルすることができたら、バグのない安全な並行プログラムを組むことができます。

次章では、Rustプログラムが肥大化する問題をモデル化し、解決策を構造化する慣例的な方法についてみていきます。
さらにRustのイディオムがオブジェクト指向プログラミングのイディオムにどのように関連しているのかみていきます。
