# パフォーマンス比較

> Ref: https://doc.rust-jp.rs/book-ja/ch13-04-performance.html

ループを使うかイテレータを使うかは、`search`関数でどちらが早いのか知る必要があります。

Sir Arthur Conan Doyleのシャーロックホームズの冒険(The Adventures of Sherlock Homes)を`String`に読み込み、そのコンテンツで`the`という単語を検索することでベンチマークを行いました。
以下が`for`を用いた`search`関数のバージョンと、イテレータを使用したバージョンのベンチマーク結果です。

```log
test bench_search_for  ... bench:  19,620,300 ns/iter (+/- 915,700)
test bench_search_iter ... bench:  19,234,900 ns/iter (+/- 657,200)
```

イテレータの方が些か高速ですね！ ここではベンチマークのコードは説明しません。
なぜなら要点は2つのバージョンが等価であることを証明することではなく、これら2つの実装がパフォーマンス的にどう比較されるかを大まかに把握することだからです。

より包括的なベンチマークとするためには、色々なサイズの様々なテキストを`contents`として異なる単語、異なる長さの単語を`query`として、他のあらゆる種類のバリエーションを確認すべきです。
重要なのはイテレータは、高度な抽象化にもかかわらず、低レベルのコードを自身で書いているかのように、ほぼ同じコードにコンパイルされることです。
イテレータはRustのゼロコスト抽象化の1つであり、これは抽象化で追加の実行時オーバーヘッドを生まないことを意味しています。
これはC++野本設計者であり実装者のBjarne Stroustrupが、ゼロオーバーヘッドを「C++の基礎(2012)」で定義したのと類似しています。

> 一般的にC++の実装は、ゼロオーバーヘッド原則を遵守します。

別の例に以下のコードは、オーディオコーダから取ってきました。
デコードアルゴリズムは、線形予測数学演算を使用して、以前のサンプルの線形関数に基づいて未来の値を予測します。
このコードはイテレータ連結のスライス、12の`coefficients`（係数）の配列、`qlp_shift`でデータをシフトする量です。
この例の中で変数を宣言しましたが、値は与えていません。
このコードは文脈の外では大して意味を持ちませんが、それでもRustが高レベルな考えを低レベルなコードに翻訳する簡潔で現実的な例になっています。

```rust
let buffer: &mut [i32];
let coefficients: [i64, 12];
let qlp_shift: i16;

for i in 12..buffer.len() {
    let prediction = coeffcients.iter()
                                .zip(&buffer[i - 12..i])
                                .map(|&c, &s| c * s as i64)
                                .sum::<i64>() >> qlp_shift;
    let delta = buffer[i];
    buffer[i] = prediction as i32 + delta;
}
```

`prediction`の値を算出するために、`cofficients`の12の値を繰り返し、`zip`メソッドを使用して、係数値を前の`buffer`の12の値とペアにします。
それから各ペアにその値を掛け合わせ、結果を全て合計し、合計のビットを`qlp_shift`ビット分だけ右にシフトさせます。

オーディオコーダのようなアプリケーションの計算は、しばしばパフォーマンスに最も重きを置きます。
ここではイテレータを作成し、2つのアダプタを使用して値を消費します。
このRustコードは、どんな機械語コードにコンパイルされるのでしょうか？
執筆時点では手作業で書いたものと同じ機械語にコンパイルされます。
`coefficients`の値の繰り返しに対応するループは全く存在しません。
コンパイラは12回繰り返しがあることを把握しているので、ループを展開します。
ループの展開はループ制御コードのオーバーヘッドを除去し、代わりにループの繰り返しごとに同じコードを生成する最適化です。

係数は全てレジスタに保存されます。つまり値に非常に高速にアクセスします。
実行時に配列の境界チェックをすることもありません。
コンパイラが適用可能なこれらの最適化すべてにより、結果のコードは究極的に効率化されます。
これらのおかげでコードは、高レベルだとしても実行時のパフォーマンスを犠牲をしいることはありません。

## まとめ

クロージャとイテレータは、関数型言語の考えに着想を得たRustの機能です。
低レベルのパフォーマンスで、高レベルの考えを明確に表現するというRustの能力に貢献しています。
クロージャとイテレータの実装は、実行時のパフォーマンスが影響されないようなものです。
これはゼロ代償抽象化を提供するのに努力を惜しまないRustの目標の一部です。

これで入出力プロジェクトの表現力を改善できたので、次は`cargo`の機能について見ていきます。
