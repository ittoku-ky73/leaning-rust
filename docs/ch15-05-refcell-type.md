# RefCell\<T>

> Ref: https://doc.rust-jp.rs/book-ja/ch15-05-interior-mutability.html

内部可変性は、そのデータへの普遍参照があるときでさえもデータを可変できるRustのデザインパターンです。
この行動は借用規則により許可されません。
データを可変化するためにこのパターンは、データ構造内で`unsafe`コードを使用して、可変性と借用を支配するRustの通常の規則を捻じ曲げています。
`unsafe`コードについては第19章で学びます。
たとえコンパイラが保証できなくても、借用規則に実行時に従うことが保証されるとき、内部可変性パターンを使用した型を使用できます。
関係する`unsafe`コードは安全なAPIにラップされ、内側の方は不変です。

内部可変性パターンに従う`RefCell<T>`型を学びつつ、この概念も身につけていきましょう。

## 借用規則を強制する

`Rc<T>`と異なり`RefCell<T>`型は、保持するデータに対して単独の所有権を表します。
ではどうして`RefCell<T>`が`Box<T>`のような型と異なるのでしょうか。
異なる理由は借用規則にあります。

- いかなる時も1つの可変参照か、いくつもの不変参照のどちらかが可能になる
- 参照は常に有効でなければならない

参照と`Box<T>`の借用規則の不変条件は、コンパイル時に強制されます。
`RefCell<T>`の不変条件は、実行時に強制されます。
参照でこれらの規則を破ると、コンパイルエラーになります。
`RefCell<T>`でこれらの規則を破ると、プログラムはパニックを起こします。

コンパイル時に借用規則を精査することの利点は、エラーが開発過程の早い段階で捕捉されることと、あらかじめすべての分析が終わるので、実行パフォーマンスへの影響がないことです。
それらの理由により多くの場合で、コンパイル時に借用規則を精査することが最善の選択肢であり、これがRustの既定になっています。

借用規則を実行時に精査する利点は、コンパイル時の精査では許容されない特定のメモリ安全な筋書きが許容されることです。
Rustコンパイラのような性的解析は本質的に保守的です。
コードの特性にはコードを解析するだけでは検知できないものもあります。
最も有名な例は停止性問題であり、ここでは学びませんが、面白いです。

不可能な分析もあるのでRustのコンパイラが、コードが所有権規則に応じていると確証を得られない場合、正しいプログラムを拒否する可能性があります。実に保守的です。
コンパイラが不正なプログラムを受け入れるとユーザーは、コンパイラが行う保証を信じられなくなるでしょう。
しかしながらコンパイラが正当なプログラムを拒否するのなら、プログラマは不便に思うでしょうが悲劇的なことは何も起こり得ません。
コードが借用規則に従っているとプログラマは確証を得ているが、コンパイラがそれを理解し保証できないときに`RefCell<T>`型が有用になります。

`Rc<T>`と類似して`RefCell<T>`もシングルスレッドで使用するための斧であり、マルチスレッドで使おうとするとコンパイルエラーになります。
`RefCell<T>`の機能をマルチスレッドのプログラムで得る方法については第16章でみます。

これまでのまとめとして、`Box<T>, Rc<T>, RefCell<T>`を選ぶ理由を要約します。

- `Rc<T>`、同じデータに複数の所有者を持たせてくれる
- `Box<T>`、不変借用も可変借用もコンパイル時に精査できる
- `RefCell<T>`、可変借用を実行時に精査できる

不変な値の中の値を可変化することは内部可変性パターンです。
次にこれが有用になるケースを見ていき、使い方も学んでいきます。

## 内部可変性
