# スマートポインタ

> Ref: https://doc.rust-jp.rs/book-ja/ch15-00-smart-pointers.html

ポインタはメモリのアドレスを含む変数の一般的な概念です。
このアドレスは何らかの他のデータを参照、または指します。
Rustにおいて最もありふれた種類のポインタは参照です。参照は第4章で習いました。
参照は`&`記号で示唆され、指している値を借用します。
データを参照すること以外に特別な能力は何もありません。
またオーバーヘッドもなく、ポインタの中では最も頻繁に使われます。

一方スマートポインタは、ポインタのように振る舞うだけでなく、追加のメタデータと能力があるデータ構造です。
スマートポインタという概念は、Rust特有のものではありません。これはC++に端を発し、他の言語にも存在します。
Rustでは標準ライブラリに定義されたいろいろなスマートポインタが、参照以上の機能を提供します。
この章で探究する1つの例が、参照カウント方式のスマートポインタ型です。
このポインタのおかげでデータを複数の所有者に持たせることができます。
所有者の数を追いかけ、所有者がいなくなったらデータの片付けをしてくれるからです。

所有権と借用の概念を使うRustにおいて、参照とスマートポインタにはもう1つ違いがあります。
参照はデータを借用するだけのポインタなのです。
対照的に多くの場合、スマートポインタは指しているデータを所有します。

私たちはすでにここでいくつかのスマートポインタに遭遇してきました。
例えば第8章の`String, Vec<T>`です。これらの方がスマートポインタに数えられるのは、あるメモリを所有しそれをいじることができるからです。
またメタデータ（キャパシティなど）や追加の能力、あるいは保証（`String`ならデータが常に有効なUTF-8であると保証することなど）もあります。

スマートポインタは普通、構造体を使用して実装されています。
スマートポインタを通常の構造体と区別する特徴は、スマートポインタが`Deref, Drop`トレイトを実装していることです。
`Deref`トレイトは、スマートポインタ構造体のインスタンスを参照のように振る舞うことができ、参照あるいはスマートポインタのどちらとも動作するコードを書くことができます。
`Drop`トレイトは、スマートポインタのインスタンスがスコープを外れた時に走るコードをカスタマイズすることができます。
この章ではどちらのトレイトについても議論し、これらのトレイトがスマートポインタにとって重要な理由を説明します。

スマートポインタパターンがRustにおいてよく使われる一般的なデザインパターンであることを考えれば、この章で既存のスマートポインタを全て取り扱うことなどできません。
多くのライブラリに独自のスマートポインタがあり、自分だけのスマートポインタを書くことさえできるのです。
ここでは標準ライブラリの最もありふれたスマートポインタを取り扱っていきます。

- `Box<T>`、ヒープに値を確保する
- `Rc<T>`、複数の所有権を可能にする参照カウント型
- `Ref<T>, RefMut<T>`、`RefCell<T>`を通してアクセスされ、コンパイル時でなく実行時に借用規則を強制する型

さらに内部可変性パターンも扱います。
そこでは不変な型が内部の値を変更するためのAPIを公開します。
また循環参照についても議論します。つまりこれによってどのようにメモリがリークするのか、そしてどのように開府するのか議論します。

さぁ、飛び込みましょう！
