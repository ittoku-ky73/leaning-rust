# オブジェクト指向言語

> Ref: https://doc.rust-jp.rs/book-ja/ch17-01-what-is-oo.html

言語がオブジェクト指向になり得る機能について、プログラミングコミュニティ内での総意はありません。
RustはOOPを含めた多くのプログラミングパラダイムに影響を受けています。
例えば第13章で関数型プログラミングに由来する機能を探究しました。
これはOOP言語の特定の一般的な特徴を共有しています。
具体的には、オブジェクト、カプセル化、継承などです。
それらの個々の特徴が意味するものとRustがサポートしているか見ていきましょう。

### オブジェクト

Enoch Gamma, Richard Helm, Ralph Johnson, John Vlissidesにより1994年に書かれた「デザインパターン：再利用可能なオブジェクト指向ソフトウェアの要素」という本は、俗に「4人のギャングの本(the Gang of four book; GoF)」と呼ばれ、オブジェクト指向デザインパターンのカタログです。
そこでOOPについて以下のように定義されています。

> オブジェクト指向プログラミングは、オブジェクトで構成される。
> オブジェクトは、データとそのデータを処理するプロシージャを梱包している。
> このプロシージャは典型的にメソッドまたはオペレーションと呼ばれる。

この定義を使用すれば、Rustはオブジェクト指向です。
構造体とenumにはデータがありますし、`impl`ブロックが構造体とenumにメソッドを提供します。
メソッドのある構造体とenumは、オブジェクトとは呼ばれないものの、GoFのオブジェクト定義によると、同じ機能を提供します。

### カプセル化

OOPと良く紐づけられる面にカプセル化があります。
これはオブジェクトの実装詳細は、そのオブジェクトを使用するコードにはアクセスできないことを意味します。
故にオブジェクトと相互作用する唯一の手段は、その公開APIを通すことです。
オブジェクトを使用するコードは、オブジェクト内部に到達して、データや振る舞いを直接変更すべきではありません。
このためプログラマはオブジェクトの内部をオブジェクトを使用するコードを変更する必要なく、リファクタリングすることができます。

カプセル化を制御する方法は、第7章で議論したように`pub`キーワードを使用して、自分のコードのどのモジュール、型、関数、メソッドを公開するかを決めることです。
例えば`i32`値のベクタを含むフィールドのある`AveragedCollection`という構造体を定義します。
この構造体はさらに、ベクタの値の平均を含むフィールドを持ちます。
つまり平均は誰かが必要とするたびに、オンデマンドで計算する必要はないということです。
言い換えれば`AveragedCollection`は、計算した平均をキャッシュしてくれるわけです。

```rust
pub struct AverageCollection {
    list: Vec<i32>,
    average: f64,
}
```

構造体は他のコードが使用できるように`pub`をつけていますが、構造体のフィールドは非公開のままです。
値が追加されたりリストから削除されるたびに、平均も更新したいので、`add, remove, average`メソッドを構造体に実装することにします。

```rust
impl AverageCollection {
    pub fn new(list: Vec<i32>, average: f64) -> AverageCollection {
        AverageCollection {
            list,
            average,
        }
    }

    pub fn add(&mut self, value: i32) {
        self.list.push(value);
        self.update_average();
    }

    pub fn remove(&mut self) -> Option<i32> {
        let result = self.list.pop();
        match result {
            Some(value) => {
                self.update_average();
                Some(value)
            }
            None => None,
        }
    }

    pub fn average(&self) -> f64 {
        self.average
    }

    fn update_average(&mut self) {
        let total: i32 = self.list.iter().sum();
        self.average = total as f64 / self.list.len() as f64;
    }
}
```

`add, remove, average`の公開メソッドが`AveragedCollection`のインスタンスを変更する唯一の方法になります。
`add, remove`メソッドを呼び出すと各メソッドの実装が`average`フィールドの更新を扱う非公開の`update_average`メソッドも呼び出します。

`list, average`フィールドを非公開のままにしているので、外部コードが要素を`list`フィールドに直接追加したり削除したりする方法はありません。
そうでなければ`average`フィールドは`list`が変更された際に同期されなくなる可能性があります。
`average`メソッドは`average`フィールドの値を返し、外部コードに`average`を表示し、変更は許可しません。

構造体`AveragedCollection`の実装詳細をカプセル化したので、データ構造などの側面を将来容易に変更することができます。
例を挙げれば`list`フィールドに`Vec<i32>`ではなく`HashSet<i32>`を使うこともできます。
`add, remove, average`といった公開メソッドのシグニチャが同じである限り、`AveragedCollection`を使用するコードは変更する必要はないでしょう。
代わりに`list`を後悔したら必ずしもこうはならないでしょう。
`HashSet<i32>, Vec<i32>`は、そうその追加と削除に異なるメソッドを持っているので、外部コードが直接`list`を変更しているのなら、外部コードも変更しなければならない可能性も高くなります。

カプセル化が言語をオブジェクト指向と考えられるのに必要な側面ならば、Rustはその条件を満たしています。
コードの異なる部分で`pub`を使用するかしないかという選択肢のおかげで、実装詳細をカプセル化することが可能になります。

### 型、共有、継承

継承はオブジェクトが他のオブジェクトの定義を受け継ぐことができる機構であり、それ故に再定義する必要なく、親オブジェクトのデータと振る舞いを得ることができます。

オブジェクト指向言語である条件に継承が含まれるのならば、Rustは違います。
親構造体のフィールドとメソッドの実装を受け継ぐ構造体を定義する方法はありません。
しかしながら継承に慣れていれば、そもそも継承に手を伸ばす理由によって、Rustで他の解決策を使用することができます。

継承を選択する理由は2つあります。
1つはコードの再利用です。ある型に特定の振る舞いを実装し、継承でその実装を他の型にも再利用できるわけです。
第10章ではデフォルトのトレイトメソッド実装を代わりに使用して、Rustコードを共有しました。
親クラスにメソッドの実装があり、継承した子クラスにもそのメソッドの実装があることと似ています。

もう1つの理由は型システムに関連しています。親の型と同じ箇所で子供の型を使用できるようにです。
これは多相性(polymorphism)とも呼ばれ、複数のオブジェクトが特定の特徴を共有しているなら、実行時にお互いに代用できることを意味します。

> ### 多相性
> 
> 多くの人にとって多相性は継承の同義語です。
> ですが実際には複数の型のデータを取り扱えるコードを指すより一般的な概念です。
> 継承について言えば、それらの型は一般的にはサブクラスです。
>
> Rustは代わりにジェネリクスを使用して様々な可能性のある型を抽象化し、トレイト境界を使用してそれらの方が提供するものに制約を課します。
> これは時にパラメータ境界多相性(bounded parametric polymorphism)と呼ばれます。

継承は近年、多くのプログラミング言語においてプログラムの設計解決策としては軽んじられています。
というのもしばしば必要以上にコードを共有してしまう可能性があるからです。
サブクラスは必ずしも親クラスの特徴を全て共有すべきではないのに、軽症ではそうなってしまうのです。
これによりプログラムの設計の柔軟性を失わせることもあります。
また道理に合わなかったり、メソッドをサブクラスに適応させないためにエラーを発生させる処理を書くという可能性が出てくるのです。
さらにサブクラスに1つのクラスからだけ継承させる言語もあり、さらにプログラムの設計の柔軟性が制限されます。

これらの理由により継承ではなくトレイトオブジェクトを使用してRustは異なるアプローチを取っています。
Rustにおいてトレイとオブジェクトがどのように多相性を可能にするか見ていきましょう。
