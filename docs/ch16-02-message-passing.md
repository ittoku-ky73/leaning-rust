# メッセージ受け渡し

> Ref: https://doc.rust-jp.rs/book-ja/ch16-02-message-passing.html

人気度を増してきている安全な平衡性を保証する1つのアプローチがメッセージ受け渡しです。
これはスレッドやアクターがデータを含むメッセージを相互に送り合うことでやり取りします。

[Go言語のドキュメンテーション](http://golang.org/doc/effective_go.html)のスローガンの1つに「メモリを共有することでやりとりするな。代わりにやりとりすることでメモリを共有しろ」というものがあります。

Rustにはチャンネルというメッセージ送信並行性を実現する道具があり、Rustの標準ライブラリが実装を提供しているプログラミング概念です。
プログラミングのチャンネルは、水の流れのように考えることができます。
アヒルのおもちゃやボートみたいなものを流れに置いたら、水路の終端まで下流に流れていきます。

プログラミングにおけるチャンネルは転送機と受信機の2つに分けることができます。
転送機はアヒルのおもちゃを川に置く上流になり、受信機はアヒルのおもちゃが行き着く下流になります。

コード内で送信したいデータとともに転送機のメソッドを呼び出し、別の部分がメッセージが到着していないか受信側を調べます。
転送機と受信機のどちらかがドロップされるとチャンネルは閉じられます。

ここで1つのスレッドが値を生成し、それをチャンネルに送信し、別のスレッドがその値を受け取り、出力するプログラムを書いてみましょう。
チャンネルを使用してスレッド間に単純な値を送り、機能の説明を行います。
一度このテクニックに慣れてしまえば、チャンネルを使用したチャットシステムや、多くのスレッドが計算の一部を担い、結果をまとめる1つのスレッドにその部分を送るようなシステムを実装できるようになります。

ではまずはチャンネルを生成してみましょう。このコードはまだコンパイルできません。

```rust
use std::sync::mpsc;

let (tx, rx) = mpsc::channel();
```

`mpsc::channel`関数で新しいチャンネルを生成しています。
`mpsc`は**multiple producer, single consumer**を表しています。

簡潔に言えば、Rustの標準ライブラリがチャンネルを実装している方法は、1つのチャンネルが値を生成する複数の送信側と、その値を消費するたった1つの受信側を持つことを意味します。
複数の小川が合わさって1つの大きな川になると、どの小川を通っても送られたものが最終的に1つの川に行き着きます。

`mpsc::channel`関数はタプルを返し、1つ目の要素は送信側、2つ目の要素は受信側になります。
`tx, rx`という略称は、多くの分野で伝統的に転送機と受信機に使用されているもので、各終端を示しています。

立ち上げたスレッドがメインスレッドとやりとりするように、転送機を立ち上げたスレッドに移動し1文字列を送ってみましょう。
これは川の上流にアヒルのおもちゃを置いたり、チャットのメッセージをあるスレッドから別のスレッドに送るみたいなものです。

```rust
use std::thread;
use std::sync::mpsc;

let (tx, rx) = mpsc::channel();

thread::spawn(move || {
    let val = String::from("hi");
    tx.send(val).unwrap();
});
```

`thread::spawn`を使用して新しいスレッドを生成し、`move`を使用して、`tx`を所有するようにクロージャにムーブしています。
立ち上げたスレッドはメッセージをチャンネルを通して送信できるように、チャンネルの送信側を所有する必要があります。

転送側には送信したい値を取る`send`メソッドがあります。
これは`Result<T, E>`型を返すので、すでに受信側がドロップされ値を送信する場所がなければ送信処理はエラーを返します。

以下のコードではメインスレッドのチャンネルの受信側から値を得ます。
アヒルのおもちゃを川の終端で水から回収したり、チャットメッセージを取得するようなものです。

```rust
let (tx, rx) = mpsc::channel();

thread::spawn(move || {
    let val = String::from("hi");
    tx.send(val).unwrap();
});

let received = rx.recv().unwrap();
println!("Got: {}", received);
```

チャンネルの受信側には有用なメソッドが2つあります。
`recv`メソッドはメインスレッドの実行をブロックし、値がチャンネルを流れてくるまで待機します。
一旦値が送信されたら、`recv`はそれを`Result<T, E>`に含んで返します。
チャンネルの送信側が閉じたら`recv`はエラーを返し、値が来ないことを通知します。

`try_recv`メソッドはブロックせず即座に`Result<T, E>`を返します。
メッセージがあれば`Ok`値を、なければ`Err`値を返します。
メッセージを待つ間にこのスレッドにすることが他にあれば、`try_recv`は有用です。
`try_recv`を頻繁に呼び出しメッセージがあったら処理し、なければ再度チェックするまでの間、他の作業をするループを書くことができます。

この例では簡潔性のために`recv`を使用しています。
メッセージを待つこと以外にメインスレッドがすべき作業はないので、メインスレッドをブロックするのは適切です。

上記のコードを実行すると以下のような出力になります。

```
Got: hi
```
