# 状態共有並行性

> Ref: https://doc.rust-jp.rs/book-ja/ch16-03-shared-state.html

メッセージ受け渡しは、並行性を扱う素晴らしい方法ですが、唯一の方法ではありません。
Go言語のドキュメントのスローガンでも「メモリを共有することでやりとりする」と書かれています。

メモリを共有することでやりとりするとはどういうことでしょうか。
さらになぜメッセージ受け渡しに熱狂的な人は、それを使わずに全く逆のことをするのでしょうか。

ある意味ではどんなプログラミング言語のチャンネルも単独の所有権に類似しています。
一旦チャンネルに値を転送したら、その値はもはや使用することがないからです。

メモリ共有並行性は、複数の所有権に似ています。
複数のスレッドが同時に同じメモリ位置にアクセスできるのです。
第15章でスマートポインタが複数の所有権を可能にしたように、異なる所有者を管理する必要があるので、複数の所有権は複雑度が上がります。
Rustの型システムと所有権規則は、この管理を正しく行う大きな助けになります。
例として、メモリ共有を行う一般的な並行性の基本型の1つであるミューテックスを見ていきましょう。

# ミューテックス

ミューテックスはどんな時も1つのスレッドのみデータへのアクセスを許可しないという**mutual exclusion**（相互排他）の省略形です。
ミューテックスにあるデータにアクセスするには、ミューテックスのロックを所望することでアクセスしたいことをスレッドに通知しなければなりません。
ロックとは現在誰かがデータへの排他的アクセスを行っているかを追跡するミューテックスの一部をなすデータ構造です。
故にミューテックスはロックシステム経由で保持しているデータを死守すると解説されます。

ミューテックスには2つの規則があり、これは覚えておく必要があります。

- データを使用する前にロックの獲得を試みなければならない。
- データの使用を終えたら他のスレッドがロックを獲得できるようにアンロックする必要がある。

ミューテックスを現実世界の物で例えるなら、マイクが1つしかない会議のパネルディスカッションになります。
パネリストが発言できる前にマイクを使用したいと申し出たり通知しなければなりません。
マイクを受け取ったら話したいことを話し、それから次に発言を申し出たパネリストにマイクを手渡します。
パネリストの発言が終わったのにマイクを手渡さなければ、他の人は発言することができません。
共有されているマイクの管理がうまくいかなければ、パネルは予定通りに機能しなくなります。

ミューテックスの管理は正しく行うのに著しく技巧を要することがあるので、多くの人はチャンネルに熱狂的になるわけです。
しかしながらRustの型システムと所有権規則のおかげで、ロックとアンロックをおかしくすることはありません。

### Mutex\<T> API

ミューテックスの使用方法の例として、ミューテックスをシングルスレッドの文脈で使うことから始めましょう。

```rust
let m = Mutex::new(5);
{
    let mut num = m.lock().unwrap();
    *num = 6;
}
println!("m = {:?}", m);
```

多くの型同様、`new`という関連関数を使用して`Mutex<T>`を生成します。
ミューテックス内部のデータにアクセスするには、`lock`メソッドを使用してロックを獲得します。
この呼び出しは現在のスレッドをブロックするので、ロックを得られる順番が来るまで何も作業はできません

ロックを保持している他のスレッドがパニックしたら、`lock`の呼び出しは失敗します。
その場合、誰もロックを取得することはできないので`unwrap`し、そのスレッドをパニックさせます。

ロックを獲得した後に`num`変数に戻り値を中に入っているデータへの可変参照として扱うことができます。
型システムにより`m`の値を使用する前にロックを獲得していることが確認されます。
`Mutex<i32>`は`i32`ではないので、`i32`を使用するにはロックを獲得しなければならないのです。

`Mutex<T>`はスマートポインタです。正確には`lock`の呼び出しで`MutexGuard`というスマートポインタを返却します。
このスマートポインタが内部のデータを指す`Deref`を実装しています。
さらに`MutexGuard`がスコープから外れたら自動的にロックを解除する`Drop`実装もしており上記のコードだと内部スコープの終わりでそれは発生します。
結果としてロックの解除が自動的に行われるので、ロック解除忘れや他のスレッドで使用されるのを阻害するリスクを負いません。

では上記のコードを実行して、内部の`i32`の値が6に変更されているか確認してみましょう。
