# ジェネリック型、トレイト、ライフタイム

> Ref: https://doc.rust-jp.rs/book-ja/ch10-00-generics.html

全てのプログラミング言語には、概念の重複を効率的に扱う道具があります。
Rustにおいて、そのような道具の1つにジェネリクスがあります。
ジェネリクスは、具体型や他のプロパティの抽象的な代役です。
コード記述の際、コンパイルやコード実行時に、ジェネリクスの位置に何が入るかを知ることなく、ジェネリクスの振る舞いや他のジェネリクスとの関係を表現できるのです。

関数が未知の値の引数を取り、同じコードを複数の具体的な値に対して走らせるように、`i32`や`String`などの具体的な型の代わりに何かジェネリックな型の引数を取ることが出来ます。
この章では、独自の型、関数、メソッドをジェネリクスとともに定義する方法を探求します。

まず関数を抽出して、コードの重複を減らす方法を確認しましょう。次に同じテクニックを活用して、引数の型のみが異なる2つの関数からジェネリックな関数を生成します。
またジェネリックな型を構造体や列挙型で使用する方法も説明します。

それからトレイトを使用して、ジェネリックな方法で振る舞いを定義する方法を学びます。
ジェネリックな型にトレイトを組み合わせることで、ジェネリックな型を単にあらゆる型に対してではなく、特定の振る舞いのある型のみに制限できます。

最後にライフタイムについて見ていきます。
ライフタイムは、コンパイラに参照がお互いにどう関係しているかの情報を与える一種のジェネリクスです。
ライフタイムのおかげでコンパイラに参照が有効であることを確認してもらうことを可能にしつつ、多くの場面で値を借用できます。

# 関数を抽出して重複を取り除く

ジェネリクスの記法を見る前に、関数を抽出することでジェネリックな型が関わらない重複を取り除く方法を見ましょう。
そしてこのテクニックを適用してジェネリックな関数を抽出します！重複したコードを認識して関数に抽出できるのと同じように、ジェネリクスを使用できる重複コードも認識できるようになります。

```rust
fn main() {
    let number_list = vec![34, 50, 25, 100, 65];

    let mut largest = number_list[0];

    for number in number_list {
        if number > largest {
            largest = number;
        }
    }

    println!("The largest number is {}", largest);
}
```

このコードは整数のリストを`number_list`に格納し、リストの最初の数字を`largest`に配置しています。
それからリストの数字を走査し、現在の数値が`largest`の数値より大きければ、その変数の値を置き換えます。
もしも小さければ、置き換えは行わず次の数値に写っていきます。
走査が全て終わった後の`largest`に入っている値は、最大値を保持しているはず。

2つの異なる数値のリストから最大値を発見するには、以下のようなコードを書きます。

```rust
fn main() {
    let number_list = vec![34, 50, 25, 100, 65];

    let mut largest = number_list[0];

    for number in number_list {
        if number > largest {
            largest = number;
        }
    }

    println!("The largest number is {}", largest);

    let number_list = vec![102, 34, 6000, 89, 54, 2, 43, 8];

    let mut largest = number_list[0];

    for number in number_list {
        if number > largest {
            largest = number;
        }
    }

    println!("The largest number is {}", largest);
}
```

このコードは動作しますが、コードを複製することになり、退屈で間違いも起こりやすいです。
また、コードを変更したいときに複数箇所、更新しなければなりません。

この重複を排除するには、引数で与えられた整数のどんなリストに対しても処理が行える関数を定義して抽象化します。
この解決策は、コードがより明確になり、リストの最大値を探すという概念を抽象的に表現してくれます。

以下のコードは、最大値を探す`largest`という関数に抽出しました。
たった1つの特定のリストからだけ最大値を探せますが、それとは異なり、このプログラムは2つの異なるリストから最大値を探せます。

```rust
fn largest(list: &[i32]) -> i32 {
    let mut largest = list[0];

    for &item in list.iter() {
        if item > largest {
            largest = item;
        }
    }

    largest
}

fn main() {
    let number_list = vec![34, 50, 25, 100, 65];

    let result = largest(&number_list);
    println!("The largest number is {}", largest);

    let number_list = vec![102, 34, 6000, 89, 54, 2, 43, 8];

    let result = largest(&number_list);
    println!("The largest number is {}", largest);
}
```

`largest`関数には`list`と呼ばれる引数があり、関数に渡す可能性のある、`i32`値の具体的なスライスを示します。
結果的に関数呼び出しの際、コードは渡した特定の値に対して走るのです。

以上のまとめとして、こちらがコードを変更した際に要したステップです。

1. 重複したコードを見分ける
2. 重複コードを関数本体に抽出し、コードの入力と戻り値を関数シグネチャで指定する
3. 重複したコードの2つの実態を代わりに関数を呼び出すように更新する

次は、この同じ手順をジェネリクスでも行なって、異なる方法でコードの重複を減らします。
関数本体が特定の値ではなく抽象的な`list`に対して処理できたのと同様に、ジェネリクスは抽象的な型に対して処理するコードを可能にしてくれます。

例えば、関数が2つあるとしましょう。
1つは`i32`あたいのスライスから最大の要素を探し、もう1つは`char`値のスライスから最大要素を探します。
この重複はどう排除するのでしょうか？次節で説明します！
