# Derefトレイト

> Ref: https://doc.rust-jp.rs/book-ja/ch15-02-deref.html

`Deref`トレイトを実装することで、参照外し演算子の`*`の振る舞いをカスタマイズできます。
`Deref`を実装してスマートポインタを普通の参照のように扱うことができれば、参照に対し処理を行うコードを書き、そのコードをスマートポインタに対して使うことができるのです。

まずは参照外し演算子が普通の参照に対して動作するところを見てみましょう。
それから`Box<T>`のように振る舞う独自の型を定義していみましょう。
参照とは異なり、新しく定義した型には参照外し演算子を使えません。その理由を確認します。
`Deref`トレイトを実装すればスマートポインタは参照と同じように機能するのでその方法を見ていきましょう。
そしてRustには参照外し強制という機能があり、その機能により参照やスマートポインタをうまく使うことができるので、こちらも紹介します。

## 参照外し演算子

普通の参照は1種のポインタであり、ポインタはどこか他の場所に格納された値への矢印と見なすことができます。
以下のコードは、`i32`の参照を生成してから参照外し演算子を使ってデータまで参照をたどります。

```rust
let x = 5;
let y = &x;

assert_eq!(5, x);
assert_eq!(5, *y);
```

`x`は5を保持しています。`y`はxへの参照として設定しています。
`x`は5に等しいとテストしています。`y`の値をテストしたい場合、参照外し演算子を使用して参照が指している値まで追いかける必要があります。
`y`の参照を外せば、`y`が指している値にアクセスすることができます。

では参照外し演算子を使用せずコンパイル使用とすると、以下のようなエラーになります。

```bash
cargo test
error[E0277]: can't compare `{integer}` with `&{integer}`
  --> src/main.rs:28:9
   |
28 |         assert_eq!(5, y);
   |         ^^^^^^^^^^^^^^^^ no implementation for `{integer} == &{integer}`
   |
   = help: the trait `PartialEq<&{integer}>` is not implemented for `{integer}`
   = help: the following other types implement trait `PartialEq<Rhs>`:
             f32
             f64
             i128
             i16
             i32
             i64
             i8
             isize
           and 6 others
   = note: this error originates in the macro `assert_eq` (in Nightly builds, run with -Z macro-backtrace for more info)
```

内容は、数値と数値の参照の比較が許されていないこと、PartialEqは数値に対して実装されていないことが書かれています。

## Box<T>を参照のように使う

上記で書いたコードは参照の代わりに`Box<T>`にすることができます。

```rust
let x = 5;
let y = Box::new(x);

assert_eq!(5, x);
assert_eq!(5, *y);
```

これらのコードの唯一の違いは、yがxの値を指す参照ではなく、xの値を指すボックスのインスタンスとして設定されている点です。
最後のテストでは、参照外し演算子を使ってボックスのポインタを辿ることができます。
参照外し演算子が使える以上、`Box<T>`には特別な何かがあるということです。
次はそれについて調べていきます。

## 独自のスマートポインタを定義

標準ライブラリが提供している`Box<T>`型に似たスマートポインタを作っていきましょう。
そうすればスマートポインタがそのままだと参照と同じようには振る舞わないことがわかります。
そしてどうすれば参照外し演算子を使えるようになるかを見ていきます。

`Box<T>`型は突き詰めると（データがヒープに置かれることを無視すると）1要素のタプル構造体のような定義になります。
なので以下のコードではそのように`<MyBox<T>`型を定義しています。

```rust
struct MyBox<T>(T);

impl<T> MyBox<T> {
    fn new(x: T) -> Self {
        MyBox(x)
    }
}
```

`MyBox`構造体を定義し、ジェネリック引数の`T`を宣言しています。`MyBox`型は型`T`の要素を1つ持つタプル構造体です。
`MyBox::new`関数は型`T`を取り、渡した値を持つ`MyBox`のインスタンスを返します。

この構造体を使用するには以下のように記述します。まだコンパイルできません。

```rust
let x = 5;
let y = MyBox::new(x);

assert_eq!(5, x);
assert_eq!(5, *y);
```

コンパイルエラーは以下のとおりです。

```
error[E0614]: type `MyBox<{integer}>` cannot be dereferenced
  --> src/main.rs:53:23
   |
53 |         assert_eq!(5, *y);
   |                       ^^

For more information about this error, try `rustc --explain E0614`.
```

`MyBox<T>`の参照は外すことはできません。まだそのための実装を与えていないからです。
`*`演算子で参照外しを行うには、`Deref`トレイトを実装します。

## Derefトレイトを実装

第10章ではトレイトを実装するために、トレイトの必須メソッドに実装を与える必要があることを学びました。
`Deref`トレイとは標準ライブラリで提供されており、`deref`という1つのメソッドの実装を要求します。
`deref`は`self`を借用し、内部のデータへの参照を返すメソッドです。

```rust
use std::ops::Deref;

impl<T> Deref for MyBox<T> {
    type Target = T;

    fn deref(&self) -> &Self::Target {
        &self.0
    }
}
```

`type Target = T;`は、`Deref`トレイトが使用する関連型を定義しています。
関連型は少し違ったやり方でジェネリック引数を宣言するためのものですが、これは第19章で詳しく見ます。

`defref`メソッドの本体は`&self.0`だけなので、`deref`が返すのは`*`演算子でアクセスしたい値の参照になります。

`Deref`トレイトがないとコンパイラは`&`参照しか参照外しできません。
`deref`メソッドのおかげでコンパイラは`Deref`を実装している方の値を取り、`deref`メソッドを呼ぶことで、参照外しが可能な`&`参照を得られるようになります。

上記のコードで参照外しの`y`を入力したとき、Rustは水面下で以下のようなコードを走らせます。

```rust
*(y.deref())
```

Rustが`*`演算子を`deref`メソッドの呼び出しと普通の参照外しとで置き換えてくれるので、私たちは`deref`メソッドを呼び出す必要があるかどうかを考えなくて済みます。
Rustのこの機能により、普通の参照か`Deref`を実装した方であるかどうかに関わらず、等しく機能するコードを書くことができます。

`deref`メソッドが値への参照を返し、`*(y.deref())`のカッコの外にある普通の参照外しがそれでも必要になるのは、所有権システムがあるからです。
`deref`メソッドが値への参照ではなく値を直接返すと値は`self`から外にムーブされます。
参照外し演算子を使用するケースはほとんどの場合、`MyBox<T>`の中の値の所有権を奪いたくありません。

`*`演算子が使えるのは、ある定義に対して1度だけです。
`*`演算子の置き換えは無限には繰り返さないので、型`i32`のデータに行き着きます。

## 参照外し型強制

参照外し型強制はコンパイラが関数やメソッドの実引数に行う便利なものです。
機能としては`Deref`を実装型への参照を`Deref`が元の型を変換できる型への参照に変換します。
また特定の型の値への参照を関数やメソッド定義の引数型と一致しない引数として関数やメソッドに渡すときに自動的に発生します。
一連の`deref`メソッドの呼び出しが、提供した型を引数が必要とする型に変換します。

参照外し型強制は、関数やメソッド呼び出しを書くプログラマが`&, *`を多用しないように追加されました。
また参照外し型強制のおかげで参照やスマートポインタのどちらかで動くコードを書きやすくなります。

参照外し型強制の動作を見るために以下のコードをご覧ください。

```rust
fn hello(name: &str) {
    println!("Hello, {}", name);
}

let m = MyBox::new(String::from("Rust"));
hello(&m);
```

`hello`関数は、文字列スライスを引数として呼び出すことができます。
しかし参照外し型強制により、`hello`を型`MyBox<String>`の値の参照でも呼び出すことができます。

`hello`関数の呼び出しの引数に`&m`を指定しています。これは`MyBox<String>`値への参照です。
`MyBox`は`Deref`トレイトを実装しているので、コンパイラは`deref`を呼び出すことで、`&MyBox<String>`を`&String`に変換することができます。

標準ライブラリは、`String`に文字列スライスを返す`Deref`の実装を提供しており、これは`Deref`のAPIドキュメントに載っています。
コンパイラはさらに`deref`を呼び出して、`&String -> &str`に変換し、これは`hello`関数の定義と合致します。

Rustに参照外し型強制が実装されていなかったら、以下のようなコードになっていたはずです。

```rust
let m = MyBox::new(String::from("Rust"));
hello(&(*m)[..]);
```

`(*m)`で参照外しを行なっています。
そして`&, [..]`により、文字列全体と等しい`String`の文字列スライスをとり、`hello`のシグネチャと一致します。
参照外し型強制のないコードは、これらの記号が関係するので、読み書きの理解が難しくなります。
参照外し型強制によりコンパイラはこれらの変換を自動的に扱ってくれます。

`Deref`トレイトが関係する型に定義されているとコンパイラは、型を分析します。
そして必要なだけ`Deref::deref`を使用して参照を引数の方と一致させます。
`Deref::deref`が挿入される必要のある回数は、コンパイル時に解決されるので、参照外し型強制を活用するための実行時の代償は何もありません。

## 参照外し型強制と可変性

`Deref`トレイトを使用して不変参照に対して`*`をオーバーライドするように、`DerefMut`トレイトを使用して可変参照の`*`演算子をオーバーライドできます。

以下の3つの場合に、型やトレイト実装を見つけたときにコンパイラは、参照型外し強制を行います。

- `T: Deref<Target=U>`、`&T -> &U`
- `T: DerefMut<Target=U>`、`&mut T -> &mut U`
- `T: Deref<Target=U>`、`&mut T -> &U`

前者2つは可変性を除いて一緒です。

最初のケースは`&T`があり、`T`が何らかの型`U`への`Deref`を実装しているなら、透過的に`&U`を得られると述べています。

2つ目のケースは同じ参照外し方強制画家編参照についても起こることを述べています。

3つ目のケースはもっと巧妙です。Rustはさらに可変参照を不変参照にも型強制します。
ですが逆はできません。不変参照は絶対に可変参照に型強制されないのです。
借用規則により可変参照があれば、その可変参照がそのデータへの唯一の参照に違いありません。
1つの可変参照を1つの普遍参照に変換することは、借用規則に違反しません。
普遍参照を可変参照にするには、そのデータへの普遍参照がたった1つしかないことが必要で、借用規則はそれを保証しません。
故に普遍参照を可変参照に変換することはできないというわけです。
