# トレイトオブジェクト

> Ref: https://doc.rust-jp.rs/book-ja/ch17-02-trait-objects.html

第8章ではベクターの制限には、1つの型の要素しか保持することができないと述べました。
これを`SpreadsheetCell`enumを定義して回避する方法を紹介しました。
この解決策は、コンパイル時に決められたセットの型がある場合に有用です。

しかし時として、ライブラリの使用者が特定の場面で型を拡張したくなる場合があります。
これを実現する例として、GUIツールの一般的なテクニックにある`draw`メソッドを呼び出してスクリーンに描画するということをやっていきます。
まずはGUIライブラリの構造を含む`gui`というライブラリクレートを作成し、`Button, TextField`などの型を包含します。
そしてこのクレートの使用者は、描画可能な独自の型(`Image, SelectBox`など)を作成できるようにします。

この例では本格的なGUIライブラリは実装しません。
`gui`では`draw`メソッドが何をしているのか知る必要はなく、ただ呼び出せることが分かれば良いのです。

継承のある言語でこれを行うには、`draw`という名前のメソッドがある`Component`というクラスを定義するかもしれません。
`Button, Image, SelectBox`などの他のクラスは、`Component`を継承し、`draw`メソッドを継承します。
個々に`draw`メソッドをオーバーライドして、独自の振る舞いを定義し、フレームワークは`Component`インスタンスであるかのようにその型全てを扱い、この型に対して`draw`を呼び出します。
しかしRustには継承はないので、使用者に新しい型で拡張してもらうために`gui`ライブラリを構成する他の方法が必要になります。

### 一般的なトレイトを定義する

`gui`に振る舞いを実装するには、`draw`というメソッドを持つ`Draw`トレイトを定義します。
そしてトレイトオブジェクトを取るベクターを定義します。
トレイトオブジェクトは、指定したトレイトを実装する型のインスタンスを指します。
`&, Box<T>`などのポインタを指定し、関係のあるトレイトを指定することでトレイトオブジェクトを作成します。
ジェネリックや具体的な型があるとトレイトオブジェクトを使うことができます。
トレイトオブジェクトを使用すると、Rustの型システムはコンパイル時にその文脈で使用されるあらゆる値がそのトレイトオブジェクトのトレイトを実装していることを保証します。
結果としてコンパイル時に可能性のある型全てを知る必要はなくなるのです。

Rustでは、構造体と列挙型を他の言語のオブジェクトと区別するためにオブジェクトと呼ぶことを避けています。
構造体や列挙型において、構造体のフィールド、データ、`impl`の振る舞いは区分けされており、他の言語でいうオブジェクトとは異なります。
しかしながらトレイトオブジェクトは、データと振る舞いをごちゃ混ぜにするという観点でいうと他の言語のオブジェクトに近いです。
しかしトレイトオブジェクトは、データを追加できないという点で伝統的なオブジェクトと異なります。
トレイトオブジェクトの目的は、共通の振る舞いに対して抽象化を行うことです。

```rust
pub trait Draw {
    fn draw(&self);
}
```
