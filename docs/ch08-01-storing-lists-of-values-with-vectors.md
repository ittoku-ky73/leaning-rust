# ベクトルを使用した値のリストの保存

> Ref: https://doc.rust-lang.org/stable/book/ch08-01-vectors.html

最初に取り上げるコレクション`Vec<T>`型は、ベクターと呼ばれています。
ベクターを使用すると、すべての値をメモリ内で並べて配置する単一のデータ構造に複数の値を格納できます。
ベクターは同じ型の値のみを格納できます。ファイル内のテキスト業やショッピングカート内のアイテムの価格など、アイテムのリストがある場合に便利です。

## 新しいベクターの作成

新しいベクターを作成するには、`Vec::new`関数を呼び出します。

```rust
let v: Vec<i32> = Vec::new();
```

ここで型注釈をつけたことに注目してください。まだこのベクターに値を挿入していないため、Rustは格納しようとしている要素の種類を知りません。これは重要なポイントです。
ベクターはジェネリックを使用して実装されます。独自の型でジェネリックを使用する方法については、第10章で説明します。今のところ、標準ライブラリによって提供される`Vec<T>`型は、任意の型を保持できることを知っておいてください。
特定の型を保持するベクターを作成する場合、山括弧内で型を指定できます。上記のコードでは、`v`が`i32`型を複数持つ`Vec<T>`で保持することをRustに伝えました。

多くの場合、`Vec<T>`で初期値を作成し、Rustが格納したい値の型を推測するため、このかた注釈を行う必要はほとんどありません。
Rustはマクロを便利に提供します。この`vec!`マクロは、指定した値を保持する新しいベクターを作成します。
以下のコードは、`v`に`1, 2, 3`の入った`Vec<i32>`を保持しています。

```rust
let v = vec![1, 2, 3];
```

初期値を与えたので、Rustは`v`変数の型を推測できるため、型注釈は必要ありません。次に、ベクターを変更する方法を見ていきます。

## ベクターの更新

ベクターに要素を追加するには、`push`メソッドを使用します。

```rust
let mut v = Vec::new();

v.push(5);
v.push(6);
v.push(7);
v.push(8);
```

内部に配置した数値はすべて`i32`型であり、Rustはデータからこれを推測します。つまり型注釈は必要ありません。

## ベクターの読み取り

ベクターに格納された値を参照するには、インデックスを作成する方法と、`get`メソッドを使用する方法の2つがあります。

```rust
let v = vec![1, 2, 3, 4, 5];

let third: &i32 = &v[2];
println!("The third element is {third}");

let third: Option<&i32> = v.get(2);
match third {
    Some(third) => println!("The third element is {third}");
    None => println!("There is no third element.");
}
```

Rustはなぜ要素を参照する方法を2つ提供しているのでしょうか。それは既知の要素の範囲外のインデックス値を使用した時にプログラムがどのように動作するか選択できるようにするためです。

```rust
let v = vec![1, 2, 3, 4, 5];

let does_not_exist = &v[100];
let does_not_exist = v.get(100);
```

インデックスで指定する方法ではパニックになりますが、`get`メソッドで指定する方法ではパニックになりません。
通常、ベクターの範囲を超える要素へのアクセスがたまに発生する可能性がある場合は、`get`メソッドを使用します。
`get`メソッドの返り値は、`Some, None`です。None値を取得した場合、現在のベクターにいくつかのアイテムがあるかユーザーに伝え、有効な値を入力する別の機会を与えることが出来ます。
タイプミスでプログラムをクラッシュさせるよりも、その方がユーザーフレンドリーです！

プログラムに有効な参照がある場合、借用は所有権と借用規則を適用して、この参照とベクターの内容へのその他の参照が有効なままであることを確認します。
可変参照と普遍参照は同じスコープ内で持つことはできないというルールを思い出してください。以下のコードでは、ベクターの最初のようの普遍の参照を保持し、最後に要素を追加しようとします。

```rust
let mut v = vec![1, 2, 3, 4, 5];

let first = &v[0];

v.push(6);

println!("The first element is: {first}");
```

このコードをコンパイルすると、次のエラーが発生します。

```bash
cargo run
   Compiling hello_cargo v0.1.0 (/Users/ittoku/Documents/learning/rust/projects/hello_cargo)
error[E0502]: cannot borrow `v` as mutable because it is also borrowed as immutable
 --> src/main.rs:6:5
  |
4 |     let first = &v[0];
  |                  - immutable borrow occurs here
5 |
6 |     v.push(6);
  |     ^^^^^^^^^ mutable borrow occurs here
7 |
8 |     println!("The first element is: {first}");
  |                                      ----- immutable borrow later used here

For more information about this error, try `rustc --explain E0502`.
error: could not compile `hello_cargo` due to previous error
```

なぜうまくいかないのでしょうか。なぜ最初の要素への参照がベクターの末尾の変更を機にする必要があるのでしょうか？
このエラーは、ベクターの動作方法によるものです。ベクターは値をメモリ内で隣り合わせに配置するため、ベクターの最後に新しい要素を追加するには、新しいメモリを割り当て、古い要素を新しいスペースにコピーする必要がある場合があります。
ベクターが現在格納されている場所に、すべての要素を隣り合わせに配置する十分なスペースがない場合、最初の要素の3章は、割り当て解除されたメモリを指していることになります。
借用規則は、プログラムがそのような状況に陥ることを防ぎます。

## ベクター内の値のループ

ベクター内の各要素に順番にアクセスするには、インデックスを使用して一度に1つずつアクセスするのではなく、すべての要素をループ処理します。

```rust
let v = vec![100, 57, 32];
for i in &v {
    println!("{i}");
}
```

ベクター内の各要素に順番にアクセスして、値を書き換えることもできます。

```rust
let mut v = vec![100, 32, 57];
for i in &mut v {
    *i += 50;
}
```

可変参照が参照する値を変更するには、`*`逆参照演算子を使用します。詳しくは第15章で説明します。

借用規則によりベクターのループ処理は、普遍であるか可変であるかに関係なく安全です。
ループ本体で項目を挿入、削除しようとするとコンパイラエラーが発生します。`for`ループが保持するベクターの3章は、ベクター全体の同時変更を防ぎます。

## 列挙型で複数の型を格納する

ベクターは同じ方のみを格納できますがこれは不便な場合があります。様々なタイプのアイテムのリストを保存する必要があるユースケースは間違いなくあります。
幸いなことに、列挙型のバリアンとは同じ列挙型で定義されているため、異なる型の要素を表すために1つの型が必要な場合は、列挙型を定義して使用できます！

例えば、行の一部の列に整数、浮動小数点数、文字列が含まれるスプレッドシートの行から値を取得したいとします。
バリアントが異なる値の方を保持する列挙型を定義でき、すべての列挙型バリアンとは同じ型、つまり列挙型とみなされます。
次にその列挙型を保持するベクターを作成できるため、最終的に様々な型を保持できます。

```rust
enum SpreadsheetCell {
    Int(i32),
    Float(i64),
    Text(String),
}

let row = vec![
    SpreadsheetCell::Int(3),
    SpreadsheetCell::Text(String::from("blue")),
    SpreadsheetCell::Float(10.12),
]
```

Rustはコンパイル時にベクターに含まれる型を知る必要があるため、各要素を格納するために必要なヒープのメモリ量を正確に把握できます。
このベクターで許可される型についても明示する必要があります。
Rustがベクターに任意の型を保持できるようにすると、1つまたは複数の型がベクターの要素に対して実行される操作でエラーを引き起こす可能性があります。
第6章で説明した、列挙型と`match`式を使用するとRustがコンパイル時に可能なすべてのケースが処理されることを保証することを意味します。

プログラムが実行時にベクターに格納するために取得する型の完全なセットがわからない場合、列挙型手法は機能しません。
代わりに特製オブジェクトを使用することができ、これは第17章で説明します。

ベクターを使用する最も一般的な方法をいくつか説明したので、標準ライブラリで定義されている多くの便利なメソッドについて、[APIドキュメント](https://doc.rust-lang.org/stable/std/vec/struct.Vec.html)を確認してください。

## ベクターを削除する

`struct`と同様に、ベクターはスコープ外になると解放されます。またベクターが削除されると、その内容もすべて削除されます。
