# UTF-8でエンコードした文字列を保存する

> Ref: https://doc.rust-lang.org/stable/book/ch08-02-strings.html

ここでは文字列についてさらに詳しく見ていきます。新しいRustaceanは一般的に、次の3つの理由の組み合わせで文字列に行き詰まります。

- Rustが潜在的なエラーを明らかにする傾向なこと
- 文字列が多くのプログラマーが認めるよりも複雑なデータ構造であること
- UTF-8

文字列はバイトのコレクションとして実装されるため、ここでは`String`のコンテキストについて説明します。
またこれらのバイトがテキストとして解釈される時に、便利な機能を提供するメソッドもいくつかあります。
このセクションでは、作成、更新、読み取りなど、すべてのコレクションタイプが持つ操作について説明します。
また`String`が他のコレクションと異なる点、つまり人間とコンピュータがデータを解釈する方法の違いにより、Stringのインデックス作成がどのように複雑になるかについても説明します。

## 文字列とは

最初に、*string*という用語の意味について説明します。Rustのコア言語には文字列型が1つだけあり、それは文字列スライス `str`で、通常は借用された形である`&str`で見られます。
第4章では、文字列スライスについて説明しました。これは他の場所に格納されているUTF-8でエンコードされた文字列データへの参照です。
例えば、文字列リテラルはプログラムのバイナリに格納されるため、文字列スライスになります。

String型は、Rustの標準ライブラリで提供される、UTF-8でエンコードされた文字列型で、成長、変更、所有可能なものです。
Rustで*string*というと、String型か、文字列スライス`&str`型のどちらかを指しますが、どちらか一方だけを指すわけではありません。
この説では、主にStringについて説明しますが、Rustの標準ライブラリでは両方の型が多用されており、Stringと&strは両方ともUTF-8でエンコードされています。

## 新しい文字列の作成

`Vec<T>`で利用できる操作の多くは、`String`でも利用できます。なぜならStringは実際にはいくつかの特別な保証、制限、および機能を持つバイトのベクターのラッパーとして実装されているからです。
Vec<T>とStringで同じように動作する関数の例として、`new`関数があります。

```rust
let mut s = String::new();
```

これは、`s`という新しい殻の文字列を作成し、そこにデータをロードすることが出来ます。多くの場合、文字列を開始するための初期データを持っているはずです。
このメソッドは、文字列リテラルがそうであるように、`Display`特性を実装している任意の型で利用できます。

```rust
let data = "initial contents";

let s = data.to_string();

// the method also works on a literal directly:
let s = "initial contents".to_string();

let s = String::from("initial contents");
```

文字列は非常に多くのことで使われるので、文字列のための多くの異なる汎用APIを使用することが出来、多くの選択肢を提供することが出来ます。
中には冗長に見えるものもありますが、どれもそれなりの意味があります。上記のコードの場合、`String::from`と`to_string`は等価なので、どちらを選ぶかはスタイルと読みやすさの問題です。

文字列はUTF-8でエンコードされているので以下のように、適切にエンコードされたデータを文字列に含めることが出来ます。

```rust
let hello = String::from("السلام عليكم");
let hello = String::from("Dobrý den");
let hello = String::from("Hello");
let hello = String::from("שָׁלוֹם");
let hello = String::from("नमस्ते");
let hello = String::from("こんにちは");
let hello = String::from("안녕하세요");
let hello = String::from("你好");
let hello = String::from("Olá");
let hello = String::from("Здравствуйте");
let hello = String::from("Hola");
```

## 文字列の更新

`String`は、`Vec<T>`の中身と同じように、より多くのデータを押し込めばサイズが大きくなり、中身が変化することがあります。
さらに、`+`演算子や、`format!`マクロを使って、Stringの値を連結することもできます。

**`push_str, push`を使って文字列を連結する。**

`push_str`メソッドは、文字列同士を連結させるのに使用し、`push`メソッドは、文字列と文字を連結させるのに使用します。

```rust
let mut s = String::from("foo");
s += "bar";
println!("s: {s}");  // s: foobar

let mut s1 = String::from("foo");
let s2 = "bar";
s1 += s2;
println!("s2 is {s2}");  // s2 is bar

let mut s = String::from("lo");
s.push('l');
println!("s: {s}");  // s: lol
```

**`+`演算子か、`format!`マクロで連結**

`+`演算子で文字列を連結するには次のように書きます。

```rust
let s1 = String::from("Hello, ");
let s2 = String::from("world!");
let s3 = s1 + &s2;
```

また`+`演算子は`add`メソッドを使用し、次のようなシグネチャになっています。

```rust
fn add(self, s: &str) -> String {}
```

標準ライブラリでは、ジェネリクスと関連する型を使って定義された`add`を見ることが出来ます。
ここでは具象型に置き換えていますが、これはString値でこのメソッドを呼び出すとどうなるか、ということです。ジェネリクスについては第10章で説明します。

まず、`s2`には`&`があります。これは最初の文字列に2番目の文字列の参照を追加していることを意味します。
これは、`add`関数の`s`パラメータが原因です。Stringに追加できるのは&strのみで2つのString値を一緒に追加することはできません。
しかし`&s2`の型は`&String`で、`add`で指定されたパラメータではありません。ではなぜ上記のコードはコンパイルできるのでしょうか。

`add`メソッドの呼び出しで、`&s2`を使用できるのはコンパイラが`&String`を`&str`に強制できるからです。
addメソッドを呼び出す時、Rustは*defer coercion*を使用し、&s2を&s2[...]に変換しています。
*defer*の強制適用については第15章で説明します。addはsパラメータの所有権を持たないので、この操作の後もs2は有効なStringのままです。

最後に、`self`が`&`を持たないため、`add`が`self`の所有権を持つことがシグネチャで確認できます。これはs1がadd呼び出しに移動され、それ以降は有効でなくなることを意味します。
つまり、`let s3 = s1 + &s2;`は両方の文字列をコピーして新しいものを作成するように見えますが、実際はs1の所有権を取得し、s2の内容のコピーを追加し、その結果の所有権を返します。
つまり、コピーを大量に作っているように見えますが、そうではなくコピーよりも効率的な実装になっているのです。

次に、`format!`マクロですが、これは複雑な文字列の結合をしたい場合に使用します。format!マクロは、println!のように動作しますが、出力を画面に表示するのではなく、その内容を文字列として返します。
また、`format!`マクロによって生成されたコードは参照を使用しているので、この呼び出しはパラメータの所有権を取りません。

```rust
let s1 = String::from("tic");
let s2 = String::from("tac");
let s3 = String::from("toe");

let s = s1 + "-" + &s2 + "-" + &s3;
let s = format!("{s1}-{s2}-{s3}");
```

## 文字列のインデックス作成

他の多くのプログラミング言語では、文字列内の個々の文字をインデックスで参照してアクセスすることは、有効で一般的な操作です。
Rustでは、インデックス構文を使用してStringの一部にアクセスしようとすると、エラーが発生します。以下のコードをご覧ください。

```rust
let s1 = String::from("hello");
let h = s1[0];
```

このコードのエラーは次のとおりです。

```bash
cargo run
   Compiling hello_cargo v0.1.0 (/Users/ittoku/Documents/learning/rust/projects/hello_cargo)
error[E0277]: the type `String` cannot be indexed by `{integer}`
  --> src/main.rs:26:13
   |
26 |     let h = s1[0];
   |             ^^^^^ `String` cannot be indexed by `{integer}`
   |
   = help: the trait `Index<{integer}>` is not implemented for `String`
   = help: the following other types implement trait `Index<Idx>`:
             <String as Index<RangeFrom<usize>>>
             <String as Index<RangeFull>>
             <String as Index<RangeInclusive<usize>>>
             <String as Index<RangeTo<usize>>>
             <String as Index<RangeToInclusive<usize>>>
             <String as Index<std::ops::Range<usize>>>

For more information about this error, try `rustc --explain E0277`.
error: could not compile `hello_cargo` due to previous error
```

Rustの文字列はインデックス作成をサポートしていません。なぜなのでしょうか。この疑問に答えるには、Rustが文字列をメモリに格納する方法について説明する必要があります。

## 内部表現

`String`は、`Vec<u8>`を包むラッパーです。以下のコードから適切にエンコードされたUTF-8文字列の例を見てみましょう。

```rust
let hello = String::from("Hola");
```

この場合、`len`は4となり、"Hola"という文字列を格納するベクターは4バイト長であることを意味します。
UTF-8でエンコードした場合、これらの文字はそれぞれ1バイトとなります。では次に、以下のコードをご覧ください。

```rust
let hello = String::from("Здравствуйте");
```

上記の文字列の長さを聞かれたら、12と答えるかもしれません。これは、"Здравствуйте"をUTF-8にエンコードするのに必要なバイト数で、この文字列内の各Unicodeスカラー値には2バイトのストレージが必要になります。
したがって、文字列のバイトへのインデックスが、常に有効なUnicodeスカラー値に関連するとは限りません。以下の無効なRustコードについて考えてみましょう。

```rust
let hello = "Здравствуйте";
let answer = &hello[0];
```

`answer`の中身は3ではありません。UTF-8でエンコードすると、3の最初のバイトは208で、2番目のバイトは151なので、答えは実際には208になるはずですが、208はそれ自体では有効な文字ではありません。
208を返すことは、ユーザーがこの文字列の最初の文字を要求した場合に望むことではありません。
一般に、ユーザーは文字列がラテン文字だけであっても、バイト値で返して欲しくありません。もし`&"hello"[0]`がバイト値を返す有効なコードであれば、hではなく104を返すでしょう。

ではその答えはというと、想定外の値を返してすぐに発見できないようなバグが発生しないように、Rustではこのコードを一切コンパイルせず、開発の早い段階で誤解を防いでいるのです。

**バイトとスカラー値と書記素クラスタ！？**

UTF-8に関するもう1つのポイントは、Rustからみた文字列には、バイト、スカラー値、書記素クラスタ（文字と呼ぶものに最も近い）の3つの関連する見方があることです。

デーヴァナーガリー文字で書かれたヒンディー語の単語"नमस्ते"を見ると、次のような`u8`値のベクターとして格納されていることがわかります。

```rust
[224, 164, 168, 224, 164, 174, 224, 164, 184, 224, 165, 141, 224, 164, 164, 224, 165, 135]
```

これはコンピュータが、最終的にこのデータを18バイトで保存します。Rustの`char`型がそうであるように、Unicodeのスカラー値としてみると、これらのバイトは次のようになります。

```rust
['न', 'म', 'स', '्', 'त', 'े']
```

しかし、4、6番目は文字ではなく、それ自体では意味をなさない発音記号です。最後にこれらを書記素クラスタとしてみると、ヒンディー語の単語を構成する、人が呼ぶところの4つの文字が出来上がります。

```rust
["न", "म", "स्", "ते"]
```

Rustは、コンピュータが記憶している生の文字列データをさまざまな方法で解釈することで、データがどのような人間の言語であっても、各プログラムが必要な解釈を選択できるようにしています。

RustがStringにインデックスを作成して文字を取得することを許可しない最後の理由は、インデックス作成にかかる時間が常に一定(O(1))であることが期待されるからです。
なぜなら、Rustは有効な文字がいくつあるかを判断するために、先頭からインデックスまで内容を走査しなければならないからです。

## 文字列をスライス

文字列のインデックス付けは、しばしば悪い考えです。文字列インデックス付操作の戻り値の型が、バイト値、文字、書記素クラスタ、文字列スライスのどれであるかが明確でないためです。
したがって、文字列スライスを作成するためにインデックスを使用する必要がある場合、Rustはより具体的に説明するよ求めます。

1つの数値に[]をつけてインデックスを作るのではなく、[]に範囲をつけることで、特定のバイトを含む文字列スライスを作ることが出来ます。

```rust
let hello = "Здравствуйте";

let s = &hello[0..4];
```

上記のコードは、`s`は文字列の最初の4バイトを含む`&str`となります。先程それぞれの文字が2バイトと書きましたが、これは`3д`となります。

もし、文字の一部のバイトだけを`&hello[0..1]`のようにスライスしようとしても、Rustはベクター内の無効なインデックスにアクセスした場合と同じように実行時にパニックを引き起こします。

文字列のスライスを作成するために範囲を使用すると、プログラムがクラッシュする可能性があるため、注意が必要です。

## 文字列をくり歌詞処理するメソッド

文字列の一部を操作する最良の方法は、文字とバイトのどちらを求めるかを明示することです。
個々のUnicodeスカラー値については、`char`メソッドを使用します。`3д`に`char`を呼び出すと、char型の2つの値が分離されて返され、その結果に対して反復処理を行うことで各要素にアクセスすることが出来ます。

```rust
for c in "3д".chars() {
    println!("{c}");
}

// Output:
// 3
// д
```

また、`bytes`メソッドではこうなります。

```rust
for b in "3д".bytes() {
    println!("{b}");
}

// Output:
// 208
// 151
// 208
// 180
```

有効なUnicodeスカラー値は、1バイト以上から構成されることがあることを覚えておいてください。

デーヴァナーガリー文字のように文字列から書記素クラスタを得るのは複雑なので、この機能は標準ライブラリでは提供されていません。
この機能が必要な場合は、crates.ioでクレートが提供されているかもしれません

## 文字列は単純ではない

要約すると、文字列は複雑だということです。プログラミング言語によって、この複雑さをどのようにプログラマに見せるか、その選択はさまざまです。
Rustは、文字列データを正しく扱うことをすべてのRustプログラムのデフォルトの動作にすることを選択しました。
これは、プログラマがUTF-8データの取り扱いを前もって考慮しなければならないことを意味します。
このトレードオフは、他のプログラミング言語よりも文字列の複雑さを露呈しますが、開発のライフサイクルの後半で非ASCII文字を含むエラーを処理する必要がなくなります。

標準ライブラリは、このような複雑な状況を正しく処理するために、String型と&str型から構築された多くの機能を提供しているのが良い点です。
文字列を検索する`contains`や、文字列の一部を別の文字列に置き換える`replace`などの便利なメソッドについては、覚えておいた方が良いでしょう。
