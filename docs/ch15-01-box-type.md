# `Box<T>`を使用する

> Ref: https://doc.rust-jp.rs/book-ja/ch15-01-box.html

最も素直なスマートポインタはボックスであり、その型は`Box<T>`と記述されます。
ボックスによりスタックではなくヒープにデータを格納することができます。
スタックに残るのはヒープデータへのポインタです。
スタックとヒープの違いを再確認するには、第4章を参照されたし。

ボックスはデータをスタックの代わりにヒープに格納する以外は、パフォーマンスのオーバーヘッドはありません。
しかし特別な能力がたくさんあるわけではなく、以下のような場面で最もよく使われます。

- コンパイル時にサイズがわからない型があり、正確なサイズを要求する文脈でその型の値を使用する時
- 多くのデータがありその所有権を移したいが、その際にデータがコピーされないようにする時
- 値を所有する必要があり、特定の型でなく、特定のトレイトを実装する型であることのみ気にかけている時

1つ目は以下の「ボックスで再起的な方を可能にする」節で説明します。

2つ目は多くのデータの所有権を転送するには、データがスタック上でコピーされるので時間がかかります。
この場面でパフォーマンスを向上させるために、多くのデータをヒープ上にボックスとして格納することができます。
そして小さなポインタのデータのみがスタック上でコピーされる一方、それが参照しているデータはヒープ上の1箇所に留まります。

3つ目はトレイとオブジェクトとして知られています。
第17章の「トレイとオブジェクトで異なる型の値を許容する」節では詳しく書かれています。
これについては第17章で説明することになります。

## `Box<T>`でヒープにデータを格納する

`Box<T>`のユースケースを議論する前に、これの記法と格納された値の読み書きする方法を見ていきます。

```rust
fn main() {
    let b = Box::new(5);
    println!("b = {}", b);
}
```

`b`を定義し`Box`の値を保持します。`Box`は5を指し、5はヒープに確保されます。
このプログラムは、`b = 5`と出力されます。つまりこの場合、このデータがスタックにあるのと同じような方法でボックスのデータにアクセスできます。

所有された値と全く同じでスコープを抜ける時、`b`は`main`の終わりで抜けるのですが、ボックスはメモリから解放されます。
メモリの解放はボックスと指しているデータに対して起こります。

ヒープに単独の値を置いても良いことはないので、このように単独でボックスを使用することはあまりありません。
単独の`i32`のような値はデフォルトでスタックに置かれます。ほとんどの場合ではその方が適切です。
ボックスで定義できるようになる方を見てみましょう。ボックスでなければそれらの型は定義すらできません。

## ボックスで再起的な型を可能にする

コンパイル時にコンパイラが知っておかなければならないのは、ある型が占有する領域の大きさです。

コンパイル時にサイズがわからない型の1つとして再起的な型があります。
この型の値は値の一部として、同じ型の他の値を持つ場合があります。
値のこうしたネストは、理論的には無限に続く可能性があるので、コンパイラは再起的な型の値が必要とする領域を知ることができないのです。
しかしながらボックのサイズはわかっているので、再起的な型の定義にボックスを挟むことで再起的な型を作ることができます。

コンスリストは関数型プログラミング言語では一般的なデータ型ですが、これを再起的な型の例として探求しましょう。
我々が定義するコンスリストは、再起を除けば素直です。

故にこれから取り掛かる例に現れる概念は、再起的な型が関わるもっと複雑な場面に遭遇した時に必ず役に立ちます。

### コンスリストについて

コンスリストはLispプログラミング言語とその方言に由来するデータ構造です。

Lispでは`cons`関数(construct function)は2つの引数から新しいペアを構成します。
この引数は通常、単独の値と別のペアからなります。これらのペアを含むペアがリストをなすのです。

`cons`関数という概念は、より一般的な関数型プログラミングの俗語にもなっています。
"to cons **x** onto **y**"は、コンテナ`y`の先頭に要素`x`をおくことで新しいコンテナのインスタンスを生成することを意味します。

コンスリストの各要素は2つの要素を含みます。現在の要素の値と次の要素です。

リストの最後の要素は、`Nil`を含み、次の要素を持ちません。
コンスリストは繰り返し`cons`関数を呼び出すことで生成されます。
繰り返しの基底ケースを示すのに標準的に使われる名前は`Nil`です。

これは`null, nil`の概念とは異なります。`null, nil`は無効だったり存在しない値です。

関数型プログラミング言語ではコンスリストは頻繁に使われますが、Rustではあまり使用されないデータ構造です。

Rustで要素のリストがあるときはほとんど、`Vec<T>`が使用されます。
より複雑な他の再起的なデータ型は様々な場面で役に立ちます。
しかしコンスリストから始めることで、ボックスのおかげで先的なデータ型を定義できるわけを、あまり気を散らすことなく調べることができます。

以下のコードは、コンスリストの`enum`定義が含まれています。
まだコンパイルはできません。`List`型のサイズが分かっていないからです。これについてはこの後説明します。

```rust
enum List {
    Cons(i32, List),
    Nil,
}
```

> この例では`i32`だけを保持するコンスリストを実装します。
> 第10章で議論したように、ジェネリクスを使用してどんな型の値も格納できるコンスリストを定義して実装することもできます。

この`List`型を使用するとなると、以下のようなコードになります。

```rust
use List::{Cons, Nil};

let list = Cons(1, Cons(2, Cons(3, Nil)));
```

最初の`Cons`値は1と別の`List`値を保持しています。
次の`Cons`値は2と別の`List`値を保持しています。
最後の`Cons`値は3と別の`List`値を保持していますが、`Nil`になっています。
`Nil`はリストの終端を通知する非再帰的な列挙子です。

コードをコンパイルしようとするとエラーになります。

```bash
error[E0072]: recursive type `List` has infinite size
 --> src/main.rs:1:1
  |
1 | enum List {
  | ^^^^^^^^^
2 |     Cons(i32, List),
  |               ---- recursive without indirection
  |
help: insert some indirection (e.g., a `Box`, `Rc`, or `&`) to break the cycle
  |
2 |     Cons(i32, Box<List>),
  |               ++++    +
```

このエラーでは、この方は無限のサイズであると示しています。
理由は再帰的な列挙子を含む`List`を定義したからです。
つまり`List`は自身の別の値を直接保持しているのです。

結果としてコンパイラは`List`値を格納するのに必要な領域が計算できません。
このエラーが出た理由は、少し噛み砕いてみましょう。
まず、非再帰的な型の値を格納するのに必要な領域をどうコンパイラが決定しているのか見てみましょう。

### 非再帰的な型のサイズを計算

第6章の`Message`enumを思い出してください。

```rust
enum Message {
    Quit,
    Move { x: i32, y: i32 },
    Write(String),
    ChangeColor(i32, i32, i32),
}
```

コンパイラは`Message`値1つにメモリを確保するのに必要な領域を決定するために、各列挙子を見てどの列挙子が最も領域を必要とするかを確認します。
`Quit`は全く領域を必要なく、`Move`は`i32`値を2つ格納する十分な領域が必要で、という風に。
となると、1つの列挙子しか使用されないので、`Message`値1つが必要とする最大の領域は、最大の列挙子を格納するのに必要になる領域となります。

これをコンパイラが`List`enumのような再帰的な型が必要とする領域を決定する時に起こることを比較してみてください。

コンパイラは`Cons`列挙子を見ます。この列挙子は`i32`1つと`List`1つが保持されます。
故に`Cons`は1つの`i32, List`のサイズに等しい領域を必要とします。
`List`が必要とするメモリ量を計算するのに、コンパイラは`Cons`列挙子から列挙子を観察します。
`Cons`列挙子は`i32`を1つと`List`1つを保持し、、、と、この過程は無限に続きます。以下のように。

![List Infinite](https://doc.rust-jp.rs/book-ja/img/trpl15-01.svg)
