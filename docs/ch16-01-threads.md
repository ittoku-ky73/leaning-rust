# スレッド

> Ref: https://doc.rust-jp.rs/book-ja/ch16-01-threads.html

多くの現代のOSでは、実行中のプログラムのコードはプロセスで走り、OSは同時に複数のプロセスを管理します。
自分のプログラム内で、独立した部分を同時に実行できます。
これらの独立した部分を走らせる機能をスレッドと言います。

プログラム内の計算を複数のスレッドに分けると、パフォーマンスが改善します。
プログラムが同時に複数の作業を行うからですが、複雑にもなります。
スレッドは同時に走らせることができるので、異なるスレッドのコードが走る順番に関して保証はしません。
これは例えば以下のような問題になる可能性があります。

- スレッドがデータやリソースに矛盾した順番でアクセスする競合状態
- 2つのスレッドがリソースを使い終わるのを待つことによるデッドロック
- 特定の状況で飲み置き、確実な再現や修正が困難なバグ

Rustではスレッドを使用する際の悪影響を軽減します。
しかしそれでもマルチスレッドの文脈でのプログラミングでは、注意深い思考とシングルスレッドで走るプログラムとは異なるコード構造が必要です。

プログラミング言語によってスレッドはいくつかの方法で実装されています。
多くのOSで新規スレッドを生成するAPIが提供されています。
言語がOSのAPIを呼び出してスレッドを生成するこのモデルを時に`1:1`と呼び、1つのOSスレッドに対して1つの言語スレッドを意味します。

多くのプログラミング言語がスレッドの独自の特別な実装を提供しています。
プログラミング言語が提供するスレッドは、グリーンスレッドと呼び、このグリーンスレッドを使用する言語は、それを異なる数のOSスレッドの文脈で実行します。
このためグリーンスレッドのモデルは`M:N`モデルと呼びます。
`M`個のグリーンスレッドに対して、`N`個のOSスレッドがあり、`M, N`は必ずしも同じ数字ではありません。

各モデルにはそれだけの利点と代償があり、Rustにとって最も重要な代償は、ランタイムのサポートです。
ランタイムは混乱しやすい用語で文脈によって意味も変わります。

ここでのランタイムとは、言語によってすべてのバイナリに含まれるコードのことを言います。
言語によってこのコードの大小は決まりますが、非アセンブリ言語はすべてある量の実行時コードを含みます。
そのため口語的に誰かが「ノーランタイム」と言ったら「小さいランタイム」のことを意味することがあります。

ランタイムが小さいと機能も少なくなるのでより多くの機能と引き換えにランタイムのサイズを膨れ上がるのは、受け入れられます。
Rustにはほとんどゼロのランタイムが必要でパフォーマンスを維持するためにCコードを呼び出すなどしたくはありません。

`M:N`グリーンスレッドモデルは、スレッドを管理するのにより大きな言語ランタイムが必要です。
よってRustの標準ライブラリは、`1:1`スレッドの実装のみを提供しています。
Rustはそのような低級言語なので例えばスレッドがいつ走るかの詳細な制御や、より低コストの文脈切り替えなどの一面をオーバーヘッドと引き換えるなら、`M:N`スレッドの実装をしたクレートもあります。

今やRustにおけるスレッドを定義したので、標準ライブラリで提供されているスレッド関連のAPIの使用法を見ていきましょう。

## spawnで新規スレッド生成

新規スレッドを生成するには`thread::spawn`関数を呼び出し、新規スレッドで走らせたいコードを含むコロージャを渡します。

```rust
use std::thread;
use std::time::Duration;

fn main() {
    thread::spawn(|| {
        for i in 1..10 {
            println!("hi number {} from the spawned thread!", i);
            thread::sleep(Duration::from_millis(1));
        }
    });

    for i in 1..5 {
        println!("hi number {} from the main thread!", i);
        thread::sleep(Duration::from_millis(1));
    }
}
```

この関数では新しいスレッドは実行が終わったかどうかに関わらずメインスレッドが終了したら停止します。
このプログラムからの出力は毎回少々異なる可能性がありますが、以下のような出力になります。

```
hi number 1 from the main thread!
hi number 1 from the spawned thread!
hi number 2 from the main thread!
hi number 2 from the spawned thread!
hi number 3 from the main thread!
hi number 3 from the spawned thread!
hi number 4 from the main thread!
hi number 4 from the spawned thread!
hi number 5 from the spawned thread!
```

`thread::sleep`を呼び出すと少しの間、スレッドは実行を止め、違うスレッドを走らせることができます。
スレッドはおそらく切り替わるでしょうが保証はありません。 OSがスレッドのスケジュールを行う方法によります。
この実行ではコード上で立ち上げられたスレッドの`print`文が先に現れているのに、メインスレッドが佐伯に出力しています。
また立ち上げたスレッドには`i`が9になるまで出力するよう指示しているのに、メインスレッドが終了する前の5までしか到達していません。

このコードを実行してメインスレッドの出力しか目の当たりにできたかったり、オーバーラップがなければ範囲の値を増やしてOSがスレッド切り替えを行う機会を増やしてみてください。
