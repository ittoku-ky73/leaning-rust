# 自動テストを書く

> Ref: https://doc.rust-jp.rs/book-ja/ch11-00-testing.html

1972年のエッセイ「謙虚なプログラマ」でエドガー・W・ダイクストラは以下のように述べています。
「プログラムのテストは、バグの存在を示すには非常に効率的な手法であるが、バグの不在を示すには望み薄く不適切である」
これは、できるだけテストを試みるべきではないということを言っているのではありません。

プログラムの正当性は、どこまで自分のコードが意図していることをしているかで決まります。
Rustは、プログラムの正当性に重きを置いて設計されていますが、正当性は複雑で、単純に証明することはありません。
Rustの型システムは、この重荷の多くの部分を肩代わりしてくれますが、あらゆる種類の不当性は補足してくれません。
故にRustでは、言語内で自動化されたソフトウェアテストを書くことをサポートしているのです。

例として、渡された何かの数値に2を足す`add_two`という関数を書くとしましょう。
この関数のシグネチャは、引数に整数を取り、結果として整数を返します。
この関数を実装してコンパイルすると、コンパイラは型チェックと借用チェックを行い、`String`の値や無効な参照をこの関数に渡していないか確かめます。
ところが、コンパイラはプログラマが意図したことを関数が実行しているかどうか、確かめることができません。
そのような場合にテストは必要となります。

テストでは、`add_two`関数に3を渡した時に、戻り値は5であることをアサーションすることができます。
コードに変更を加えた際にこれらのテストを走らせ、既存の正当な振る舞いが変わっていないことを確認できます。

テストは複雑なスキルです。これがいいテストの書き方だというものはありません。
ここではRustのテスト機構のメカニズムについて説明します。
テストを書く際に利用可能となるアノテーションとマクロについてや、テストを実行する際に提供されるオプションと標準の動作、ユニットテストや統合テストに体系化する方法について説明します。
