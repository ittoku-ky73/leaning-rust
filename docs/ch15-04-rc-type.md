# Rc\<T>

> Ref: https://doc.rust-jp.rs/book-ja/ch15-04-rc.html

どの変数が与えられた値を所有しているかどうかは大抵の場合、把握できます。
しかし単独の値に複数の所有者を指定したいケースもあります。
例えばグラフデータ構造では、複数の辺が同じノードを指す可能性があり、概念的にはそのノードはそれを指すすべての辺に所有されるわけです。
指す辺がなくならない限り、ノードは片付けられるべきではありません。

Rustには`Rc<T>`という型があり、これは参照カウント(reference counting)の省略形で、複数の所有権を可能にします。
`Rc<T>`型は、値がまだ使用中かどうかを決定する値への参照の数を追跡します。
値への参照が0なら値は片付けられます。

`Rc<T>`を家族部屋のテレビと想像してみてください。
一人がテレビを見に部屋に入ったらテレビをつけます。
他の人も部屋に入ってテレビを見ることができます。
最後の人が部屋を離れるとき、テレビはもう使用されないので消します。
他の人がまだ見ているのに誰かがテレビを消したら、怒られます。

ヒープにプログラムの複数箇所で読む何らかのデータを確保したいが、コンパイル時にはどの部分が最後にデータを使い終わるかわからないときに`Rc<T>`型を使用します。
いつ使い終わるかが分かっているなら、単にその部分をデータの所有者にして、コンパイル時に強制される普通の所有権ルールを使えば良いだけです。

`Rc<T>`はシングルスレッドのみ使用できます。
第16章で並行性について学ぶ際に、マルチスレッドプログラムでの参照カウントをする方法を見ていきます。

## データを共有する

前に学んだコンスリストで`Box<T>`を使ったことを思い出してください。
今回は両方とも3番目のリストの所有権を共有する2つのリストを作成します。
これは概念的には以下のような見た目になります。

![list](https://doc.rust-jp.rs/book-ja/img/trpl15-03.svg) 

5と10を含むリスト`a`を作成します。さらに2つのリストも作ります。
`b = 3`と`c = 4`のリストです。
`b, c`のどちらも`a`のリストに続きます。
つまりどちらのリストも5と10を含む最初のリストを共有しています。

これは`List`の定義を使用して`Box<T>`と共に実装しようとしてもうまくいきません。

```rust
enum List {
    Cons(i32, Box<List>),
    Nil
}

use List::{Cons, Nil};

let a = Cons(5,
    Box::new(Cons(10,
        Box::new(Nil))));
let b = Cons(3, Box::new(a));
let b = Cons(4, Box::new(a));
 
```

コードをコンパイルしようとすると以下のようなエラーを吐きます。

```
error[E0382]: use of moved value: `a`
   --> src/main.rs:114:34
    |
110 |         let a = Cons(5,
    |             - move occurs because `a` has type `List`, which does not implement the `Copy` trait
...
113 |         let b = Cons(3, Box::new(a));
    |                                  - value moved here
114 |         let b = Cons(4, Box::new(a));
    |                                  ^ value used here after move

For more information about this error, try `rustc --explain E0382`.
```

`Cons`列挙子は保持しているデータを所有するので、`b`を作成するときに`a`が`b`にムーブされ、`b`が`a`を所有します。
それから`c`を作る際に再度`a`を使用とすると`b`はムーブ済みなので、できないわけです。

`Cons`の定義の代わりに参照を保持するように変更することもできますが、その場合ライフタイム引数を指定しなければなりません。
ライフタイム引数を指定することで、リストの各要素が最低でもリスト全体と同じ期間だけ生きることを指定することになります。
例えば借用チェッカーは`let a = Cons(10, &Nil)`をコンパイルさせてくれません。
一時的な`Nil`値が、`a`を参照する前にドロップされてしまうからです。

代わりに`List`の定義を`Box<T>`の箇所に`Rc<T>`を使うように変更します。
これで各`Cons`列挙子は、値と`List`を指す`Rc<T>`を保持するようになります。
`b`を作る際`a`の所有権を奪うのではなく、`a`が保持している`Rc<List>`をクローンします。
それによって参照の数が1から2に増え、`a, b`に`Rc<List>`にあるデータの所有権を共有させます。
また`c`を作成する際にも`a`をクローンするので、3章の数は2から3になります。
`Rc::clone`を呼ぶたびに、`Rc<List>`ないのデータの参照カウントが増え、0にならない限りデータは片付けられません。

```rust
enum List {
    Cons(i32, Rc<List>),
    Nil,
}

use List::{Cons, Nil};
use std::rc::Rc;

let a = Rc::new(Cons(5, Rc::new(Cons(10, Rc::new(Nil)))));
let b = Cons(3, Rc::clone(&a));
let c = Cons(4, Rc::clone(&a));
```

`Rc<T>`を使用するには、`use std::rc::Rc;`を記述する必要があります。
5と10を保持するリストを作成し、`a`の新しい`Rc<List>`に格納します。
それから`b, c`を作成する前に、`Rc::clone`関数を呼び出し、引数として`a`の`Rc<List>`の参照を渡しています。

`Rc::clone(&a)`ではなく、`a.clone()`を呼ぶこともできますが、Rustのしきたりでは`Rc::clone`を使います。
`Rc::clone`の実装は、多くの型の`clone`実装のように、すべてのデータのディープコピーをすることではありません。
`Rc::clone`の呼び出しは、参照カウントをインクリメントするだけであり、時間はかかりません。
データのディープコピーは時間がかかることもあります。
参照カウントに`Rc::clone`を使うことで、視覚的にディープコピーする類のクローンと参照カウントを増やす種類のクローンを区別することができます。
コード内でパフォーマンスの問題を探す際、ディープコピーのクローンだけを考慮し、`Rc::clone`の呼び出しを無視できるのです。

## Rc\<T>をクローン

`a`の`Rc<List>`への参照を作りドロップする度に参照カウントが変化を出力するようにします。

以下のコードは、リスト`c`を囲む内側のスコープができるように変更しています。
こうすることで`c`がスコープを抜けるときに参照カウントがどう変化するか確認できます。

```rust
let a = Rc::new(Cons(5, Rc::new(Cons(10, Rc::new(Nil)))));
println!("count after creating a = {}", Rc::strong_count(&a));
let _b = Cons(3, Rc::clone(&a));
println!("count after creating b = {}", Rc::strong_count(&a));
{
    let _c = Cons(4, Rc::clone(&a));
    println!("count after creating c = {}", Rc::strong_count(&a));
}
println!("count after c goes out of scope = {}", Rc::strong_count(&a));
```

プログラム内で参照カウントが変更される度に、参照カウントを出力します。
参照カウントは、`Rc::strong_count`関数を呼び出すことで得られます。
`Rc<T>`型には`weak_count`関数もあり、これは「循環参照を回避」節で見ていきます。

上記のコードは以下の出力を行います。

```
count after creating a = 1
count after creating b = 2
count after creating c = 3
count after c goes out of scope = 2
```

`a`の参照カウントは`clone`を呼び出す度に、増えていっていることがわかります。
`c`がスコープを抜けると、カウントは1つ下がります。

`Rc<T>`を使用すると単独の値に複数の所有者を持たせることができ、所有者のいずれかが存在している限り、値で有効であり続けることをカウントは保証します。

不変参照経由で、`Rc<T>`は読み取り専用にプログラムの複数箇所間でデータを共有してくれます。
もし`Rc<T>`が複数の可変参照を存在させることも許可してしまったら、借用ルールを侵害する恐れがあります。
しかしデータを可変化する能力はとても有用です。
次節では内部可変性パターンと`Rc<T>`と絡めて普遍性制限を手がけられる`RefCell<T>`型についてみていきます。
