# イテレータ

> Ref: https://doc.rust-jp.rs/book-ja/ch13-02-iterators.html

イテレータパターンは、一連の要素に順番に何らかの作業を行うことができます。
イテレータは各要素を繰り返し、シーケンスが終わったことを決定するロジックの責任を負います。
イテレータを使用すると、自身でそのロジックを再実装する必要がなくなります。

Rustにおいてイテレータは怠惰です。
つまりイテレータを使い込んで消費するメソッドを呼ぶまで何の効果もないということです。
例えば以下のコードでは、`Vec<T>`に定義された`iter`メソッドを呼ぶことで`v1`ベクターの要素に対するイテレータを生成しています。
このコード単独では何も有用なことはしません。

```rust
let v1 = vec![1, 2, 3];

let v1_iter = v1.iter();
```

一旦イテレータを生成したら、いろいろな手段で使用することができます。
`for`ループでイテレータを使うことで、各要素に何かしらのコードを実行することができます。

以下の例では、イテレータの生成と`for`ループでイテレータを使用することを区別しています。
イテレータは`v1_iter`変数に保存され、まだ繰り返しは起きていません。
`v1_iter`のイテレータで、`for`ループが呼び出された時に、イテレータの各要素がループの繰り返しで使用され、出力されます。

```rust
let v1 = vec![1, 2, 3];

let v1_iter = v1.iter();

for val in v1_iter {
    println("Got: {}", val);
}
```

標準ライブラリにより提供されるイテレータが存在しない言語では、変数を0からはじめ、その変数でベクターにアクセスして値を得ます。
ベクターの装用素数に到達するまでその変数の値をインクリメントすることで、この同じ機能を欠く可能性が高いでしょう。

イテレータはそのロジック全てを処理してくれるので、メチャクチャにしてしまう可能性のあるコードの繰り返しを減らしてくれます。
イテレータにより、添字を使えるデータ構造、ベクターなどだけでなく多くの異なるシーケンスに対して同じロジックを使う柔軟性も得られます。

## `Iterator`トレイト、`next`メソッド

全てのイテレータは、標準ライブラリで定義されている`Iterator`というトレイトを実装しています。
このトレイトの定義は以下のようになっています。

```rust
pub trait Iterator {
    type Item;

    fn next(&mut self) -> Option<Self::Item>;

    // methods with default implementations elided
}
```

この定義では`type Item, Self::Item`という新しい記法を使用しています。
これらはトレイトとの関連型(associated type)を定義しています。関連型についての詳細は第19章でみていきます。
とりあえずこのコードを`Iterator`トレイトとして実装するには`Item`型も定義する必要があり、
そしてこの`Item`型が`next`メソッドの戻り値の型に使われるということです。

`Iterator`トレイトは、1つのメソッドを定義することを実装者に要求します。
それは`next`メソッドで、`Some`に包まれたイテレータの1要素を返し、終わったら`None`を返します。

イテレータに対して直接`next`メソッドを呼び出すこともできます。

```rust
#[test]
fn iterator_demonstration() {
    let v1 = vec![1, 2, 3];

    let mut v1_iter = v1.iter();

    assert_eq!(v1_iter.next(), Some(&1));
    assert_eq!(v1_iter.next(), Some(&2));
    assert_eq!(v1_iter.next(), Some(&3));
    assert_eq!(v1_iter.next(), None);
}
```

`v1_iter`は可変にする必要があります。
イテレータの`next`メソッドを呼び出すと、今シーケンスのどこにいるかを追いかけるためにイテレータが使用している内部の状態が変わります。
つまりこのコードはイテレータを消費、または使い込むのです。
`next`の各呼び出しは、`v1_iter`を可変にする必要はありませんでした。
というのもループが`v1_iter`の所有権を奪い、陰で可変にしていたからです。

また`next`の呼び出しで得られる値は、ベクターの値への不変な参照でもあります。
`iter`メソッドは、不変参照へのイテレータを生成します。
`v1`の所有権を奪い、所有された値を返すイテレータを生成したいなら、`iter`ではなく`into_iter`を呼び出します。
同様に可変参照を繰り返したいなら、`iter`ではなく`iter_mut`を呼び出します。

## イテレータを消費するメソッド

`Iterator`トレイトには、標準ライブラリが提供してくれているデフォルト実装のある多くの異なるメソッドがあります。
これらのメソッドの中には、定義内で`next`メソッドを呼ぶものもあり、故に`Iterator`トレイトを実装する際には、`next`メソッドを実装する必要があるのです。

`next`を呼び出すメソッドは、消費アダプタ(consuming adaptors)と呼ばれます。
呼び出しがイテレータの使い込みになるからです。
`sum`メソッドはイテレータの所有権を奪い、`next`を繰り返し呼び出すことで要素を繰り返し、イテレータを消費します。
繰り返しが進むごとに、各要素を一時的な合計に追加し、繰り返しが完了したらその合計を返します。

```rust
#[test]
fn iterator_sum() {
    let v1 = vec![1, 2, 3];

    let mut v1_iter = v1.iter();

    let total: i32 = v1_iter.sum();

    assert_eq!(total, 6);
}
```

`sum`は呼び出し対象のイテレータの所有権を奪うので、`sum`呼び出し後に`v1_iter`を使用することはできません。

## 他のイテレータを生成するメソッド

`Iterator`トレイトに定義された他のメソッドは、イテレータアダプタ(Iterator Adaptors)として知られていますが、イテレータを別の種類のイテレータに変えさせてくれます。
イテレータアダプタの複数回の呼び出しを連結して、複雑な動作を読みやすい形で行うことができます。
ですが全てのイテレータは怠惰なので、消費アダプタメソッドのどれかを呼び出し、イテレータアダプタの呼び出しから結果を得なければなりません。

以下の例は、イテレータアダプタメソッドの`map`を呼び出し、各要素に対して呼び出すクロージャを取り、新しいイテレータを生成します。

```rust
let v1: Vec<i32> = vec![1, 2, 3];

v1.iter().map(|x| x + 1);
```

上記のコードは何もしません。 指定したクロージャは、決して呼ばれないのです。
イテレータアダプタは怠惰で、ここでイテレータを消費する必要があります。

イテレータを消費するには、`collect`メソッドを使用します。
このメソッドはイテレータを消費し、結果の値をコレクションデータ型に集結します。

```rust
let v1: Vec<i32> = vec![1, 2, 3];

let v2: Vec<_> = v1.iter().map(|x| x + 1).collect();

assert_eq!(v2, vec![2, 3, 4]);
```

`map`はクロージャを取るので、各要素に対してどんな処理でも指定することができます。
これは`Iterator`トレイトが提供する繰り返し動作を再利用しつつ、クロージャにより一部の動作をカスタマイズできることを意味します。

## クロージャを使用する

イテレータが出てきたので、`filter`イテレータアダプタを使って環境をキャプチャするクロージャの一般的な使用を見ることができます。
`filter`メソッドが、イテレータの各要素を取り、論理値を返すクロージャを取ります。
このクロージャが`true`を返すと`filter`が生成するイテレータに値が含まれ、`false`を返すと値は含まれません。

```rust
#[derive(PartialEq, Debug)]
struct Shoe {
    size: u32,
    style: String,
}

fn shoes_in_my_size(shoes: Vec<Shoe>, shoe_size: u32) -> Vec<Shoe> {
    shoes.into_iter()
        .filter(|s| s.size == shoe_size)
        .collect()
}

#[test]
fn filters_by_size() {
    let shoes = vec![
        Shoe { size: 10, style: String::from("sneaker") },
        Shoe { size: 13, style: String::from("sandal") },
        Shoe { size: 10, style: String::from("boot") },
    ];

    let in_my_size = shoes_in_my_size(shoes, 10);

    assert_eq!(
        in_my_size,
        vec![
            Shoe { size: 10, style: String::from("sneaker") },
            Shoe { size: 10, style: String::from("boot") },
        ]
    );
}
```

`shoes_in_my_size`関数は、引数として靴のベクターとサイズの所有権を奪います。
そして指定されたサイズの靴だけを含むベクターを返します。

この関数の中で、`into_iter`を呼び出してベクターの所有権を奪うイテレータを作成しています。
そして`filter`を呼び出し、イテレータをクロージャが`true`を返した要素を含む新しいイテレータに適合させます。

クロージャは環境から`shoe_size`引数をキャプチャし、指定されたサイズの靴だけを保持しながら、その値を各靴のサイズと比較します。
最後に`collect`を呼び出して、関数から帰ってきたベクターに適合させたイテレータから帰ってきた値が集まります。

`shoes_in_my_size`を呼び出した時に、指定した値と同じサイズの靴だけが得られることをテストしています。

## `Iterator`トレイトで独自のイテレータを作成

ベクターに対し、`iter, into_iter, iter_mut`を呼び出すことでイテレータを生成してきました。
ハッシュマップなどの標準ライブラリの他のコレクション型からもイテレータを作成できます。
`Iterator`トレイトを自分で実装することで、特別なイテレータを作成することもできます。
前述の通り、定義を提供する必要のある唯一のメソッドは、`next`メソッドなのです。
いったん定義してしまえば、`Iterator`トレイトが用意しているデフォルト実装のある他のすべてのメソッドを使うことができるのです！

試しに絶対に1から5をカウントするだけのイテレータを作成してみましょう。

```rust
struct Counter {
    count: u32,
}

impl Counter {
    fn new() -> Counter {
        Counter { count: 0 }
    }
}
```

`Counter`構造体には`count`というフィールドがあります。
このフィールドは、1から5までの繰り返しのどこにいるかを追いかける`u32`値を保持しています。
`Counter`の実装にその値を管理してほしいので、`count`フィールドは非公開です。
`count`フィールドは常に0の値から新規インスタンスを生成する動作を`new`関数で強要します。

次に`next`メソッドの本体をこのイテレータが使用された際に期待する動作を指定します。

```rust
impl Iterator for Counter {
    type Item = u32;

    fn next(&mut self) -> Option<Self::Item> {
        self.count += 1;

        if self.count < 6 {
            Some(self.count)
        } else {
            None
        }
    }
}
```

イテレータの`Item`関連型を`u32`に設定しました。 つまりイテレータは、`u32`の値を返します。
関連型については第19章で説明します。

イテレータの現在の状態に1を足してほしいので、まず1を返すように`count`を0に初期化します。
`count`が5以下なら`Some`に包まれた現在の値を返し、6以上なら`None`を返します。

### `Counter`イテレータの`next`メソッド

一旦`Iterator`トレイトを実装し終えたら、イテレータの出来上がりです！
以下のコードは、`next`を呼び出して`Counter`構造体のイテレータ機能がうまく動作しているかテストしています。

```rust
#[test]
fn calling_next_directly() {
    let mut counter = Counter::new();

    assert_eq!(counter.next(), Some(1));
    assert_eq!(counter.next(), Some(2));
    assert_eq!(counter.next(), Some(3));
    assert_eq!(counter.next(), Some(4));
    assert_eq!(counter.next(), Some(5));
    assert_eq!(counter.next(), None);
}
```

### 他の`Iterator`トレイトメソッドを使用する

`next`メソッドを定義して`Iterator`トレイトを実装したので、今では標準ライブラリで定義されているように、どんな`Iterator`トレイトメソッドのデフォルト実装も使えるようになりました。
全て`next`メソッドの機能を使用しているからです。

以下のコードは、まず`Counter`インスタンスが生成する値を取ります。
そして最初の値を飛ばして、別の`Counter`インスタンスが生成する値と1組にします。
最後に各ペアを掛け算し、3で割り切れる結果だけを残し、全結果の値を足し合わせています。

```rust
#[test]
fn using_other_iterator_trait_methods() {
    let sum: u32 = Counter::new().zip(Counter::new().skip(1))
        .map(|(a, b)| a * b)
        .filter(|x| x % 3 == 0)
        .sum();

    assert_eq!(18, sum);
}
```

`zip`は4組しか生成しません。
理論的な5番目のペアの`(5, None)`は、入力イテレータのどちらかが`None`を返すと`zip`は`None`を返却するため決して生成されることがありません。

`next`メソッドの動作方法を指定し、標準ライブラリが`next`を呼び出す他のメソッドにデフォルト実装を提供しているので、これらのメソッド呼び出しは全て可能です。
