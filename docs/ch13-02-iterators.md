# イテレータ

> Ref: https://doc.rust-jp.rs/book-ja/ch13-02-iterators.html

イテレータパターンは、一連の要素に順番に何らかの作業を行うことができます。
イテレータは各要素を繰り返し、シーケンスが終わったことを決定するロジックの責任を負います。
イテレータを使用すると、自身でそのロジックを再実装する必要がなくなります。

Rustにおいてイテレータは怠惰です。
つまりイテレータを使い込んで消費するメソッドを呼ぶまで何の効果もないということです。
例えば以下のコードでは、`Vec<T>`に定義された`iter`メソッドを呼ぶことで`v1`ベクターの要素に対するイテレータを生成しています。
このコード単独では何も有用なことはしません。

```rust
let v1 = vec![1, 2, 3];

let v1_iter = v1.iter();
```

一旦イテレータを生成したら、いろいろな手段で使用することができます。
`for`ループでイテレータを使うことで、各要素に何かしらのコードを実行することができます。

以下の例では、イテレータの生成と`for`ループでイテレータを使用することを区別しています。
イテレータは`v1_iter`変数に保存され、まだ繰り返しは起きていません。
`v1_iter`のイテレータで、`for`ループが呼び出された時に、イテレータの各要素がループの繰り返しで使用され、出力されます。

```rust
let v1 = vec![1, 2, 3];

let v1_iter = v1.iter();

for val in v1_iter {
    println("Got: {}", val);
}
```

標準ライブラリにより提供されるイテレータが存在しない言語では、変数を0からはじめ、その変数でベクターにアクセスして値を得ます。
ベクターの装用素数に到達するまでその変数の値をインクリメントすることで、この同じ機能を欠く可能性が高いでしょう。

イテレータはそのロジック全てを処理してくれるので、メチャクチャにしてしまう可能性のあるコードの繰り返しを減らしてくれます。
イテレータにより、添字を使えるデータ構造、ベクターなどだけでなく多くの異なるシーケンスに対して同じロジックを使う柔軟性も得られます。

## `Iterator`トレイト、`next`メソッド

全てのイテレータは、標準ライブラリで定義されている`Iterator`というトレイトを実装しています。
このトレイトの定義は以下のようになっています。

```rust
pub trait Iterator {
    type Item;

    fn next(&mut self) -> Option<Self::Item>;

    // methods with default implementations elided
}
```

この定義では`type Item, Self::Item`という新しい記法を使用しています。
これらはトレイトとの関連型(associated type)を定義しています。関連型についての詳細は第19章でみていきます。
とりあえずこのコードを`Iterator`トレイトとして実装するには`Item`型も定義する必要があり、
そしてこの`Item`型が`next`メソッドの戻り値の型に使われるということです。

`Iterator`トレイトは、1つのメソッドを定義することを実装者に要求します。
それは`next`メソッドで、`Some`に包まれたイテレータの1要素を返し、終わったら`None`を返します。

イテレータに対して直接`next`メソッドを呼び出すこともできます。

```rust
#[test]
fn iterator_demonstration() {
    let v1 = vec![1, 2, 3];

    let mut v1_iter = v1.iter();

    assert_eq!(v1_iter.next(), Some(&1));
    assert_eq!(v1_iter.next(), Some(&2));
    assert_eq!(v1_iter.next(), Some(&3));
    assert_eq!(v1_iter.next(), None);
}
```

`v1_iter`は可変にする必要があります。
イテレータの`next`メソッドを呼び出すと、今シーケンスのどこにいるかを追いかけるためにイテレータが使用している内部の状態が変わります。
つまりこのコードはイテレータを消費、または使い込むのです。
`next`の各呼び出しは、`v1_iter`を可変にする必要はありませんでした。
というのもループが`v1_iter`の所有権を奪い、陰で可変にしていたからです。

また`next`の呼び出しで得られる値は、ベクターの値への不変な参照でもあります。
`iter`メソッドは、不変参照屁のイテレータを生成します。
`v1`の所有権を奪い、所有された値を返すイテレータを生成したいなら、`iter`ではなく`into_iter`を呼び出します。
同様に可変参照を繰り返したいなら、`iter`ではなく`iter_mut`を呼び出します。

## イテレータを消費するメソッド

`Iterator`トレイトには、標準ライブラリが提供してくれているデフォルト実装のある多くの異なるメソッドがあります。
これらのメソッドの中には、定義内で`next`メソッドを呼ぶものもあり、故に`Iterator`トレイトを実装する際には、`next`メソッドを実装する必要があるのです。

`next`を呼び出すメソッドは、消費アダプタ(consuming adaptors)と呼ばれます。
呼び出しがイテレータの使い込みになるからです。
`sum`メソッドはイテレータの所有権を奪い、`next`を繰り返し呼び出すことで要素を繰り返し、イテレータを消費します。
繰り返しが進むごとに、各要素を一時的な合計に追加し、繰り返しが完了したらその合計を返します。

```rust
#[test]
fn iterator_sum() {
    let v1 = vec![1, 2, 3];

    let mut v1_iter = v1.iter();

    let total: i32 = v1_iter.sum();

    assert_eq!(total, 6);
}
```

`sum`は呼び出し対象のイテレータの所有権を奪うので、`sum`呼び出し後に`v1_iter`を使用することはできません。

## 他のイテレータを生成するメソッド



## クロージャを使用する



## `Iterator`トレイトで独自のイテレータを作成



### `Counter`イテレータの`next`メソッド



### 他の`Iterator`トレイトメソッドを使用する
