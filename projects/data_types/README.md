# データ型

> 参考：https://doc.rust-lang.org/book/ch03-02-data-types.html

Rustの全ての値は特定のデータ型であり、指定されているデータの種類をRustに伝え、そのデータの操作方法を認識しています。スカラーと複合の2つのデータ型サブセットを見ていきましょう。

Rustは制定機に型付けされた言語です。つまりコンパイル時に全ての変数の方を認識している必要があります。コンパイラは通常、値とその使用方法に基づいて使用する型を推測できます。

```rust
let guess: u32 = "42".parse().expect("Not a number!");
```

上記のコードで、`u32`を含めずにコンパイルした場合エラーになります。

```error
cargo run
   Compiling data_types v0.1.0 (/Users/ittoku/Documents/learning-rust/projects/data_types)
error[E0282]: type annotations needed
 --> src/main.rs:2:9
  |
2 |     let guess = "42".parse().expect("Not a number!");
  |         ^^^^^
  |
help: consider giving `guess` an explicit type
  |
2 |     let guess: _ = "42".parse().expect("Not a number!");
  |              +++

For more information about this error, try `rustc --explain E0282`.
error: could not compile `data_types` due to previous error
```

## スカラー型

スカラー型は単一の値を表します。Rustには、整数、浮動小数点数、ブール値、文字の4つの主要なスカラー型があります。これらがRustでどのように機能するか見ていきましょう。

### 整数型

整数は、少数部分のない数値です。上記の`u32`の型宣言は、32ビットのスペースを占める符号なし整数（符号付き整数型は`u`ではなく`i`から始まる）であることを示しています。

| Length  | Signed | Unsigned |
| ------- | ------ | -------- |
| 8-bit   | i8     | u8       |
| 16-bit  | i16    | u16      |
| 32-bit  | i32    | u32      |
| 64-bit  | i64    | u64      |
| 128-bit | i128   | u128     |
| arch    | isize  | usize    |

各バリアントは、`signed, unsigned`か、明示的なサイズを持ちます。符号付きと符号なしは、数値が負になる可能性があるかどうかを示します。つまり符号（`+`とか`-`とか）をつけるか（signed）、つけないか（unsigned）で決まります。ただし、数値が生であると想定しても安全な場合は、符号なしで表示されます。符号付き数値は、2の補数表現を使用して格納されます。

つまり符号付きと符号なしの表すことのできる数値は次のようになります。`size`は、`2**8-1`した数です。

| variant | size | range    |
| ------- | ---- | -------- |
| i8      | 255  | -128~127 |
| u8      | 255  | 0~255    |

さらに、`isize, usize`タイプは、プログラムが実行されているコンピュータのアーキテクチャによって異なります。64ビットアーキテクチャの場合は64ビット、32ビットアーキテクチャの場合は32ビットになります。

整数リテラルは、以下の表のように任意の形式で記述することができます。

| Number literals | Example     |
| --------------- | ----------- |
| Decimal         | 98_222      |
| Hex             | 0xff        |
| Octal           | 0o77        |
| Binary          | 0b1111_0000 |
| Byte (u8 only)  | b'A'        |

使用する型がよくわからない場合は、Rustのデフォルトから始めるのが一般的です。整数型のデフォルトは`i32`です。`isize, usize`を使用する主な状況は、ある種のコレクションにインデックスをつける場合です。

**整数オーバーフロー**

変数をその範囲外の値に変更しようとすると、整数オーバーフローが発生し、2つの動作のいずれかが発生する可能性があります。

デバッグモードでコンパイルする場合、Rustには整数オーバーフローのチェックが含まれており、この動作が発生すると実行時にプログラムがパニックに陥ります。Rustでは、プログラムがエラーで終了する時にパニックという用語を使用します。

リリースモードでコンパイルする場合、Rustには整数オーバーフローのチェックは含まれておらず、代わりにオーバーフローが発生した場合、Rustは2の補数ラッピングを実行します。つまり、型が保持できる最大値よりも大きい値は、型が保持できる最小値に「ラップアラウンド」します。つまり、型が`u8`の場合、256は0、257は1となります。

オーバーフローの可能性を明示的に処理するには、プリミティブ数値型の標準ライブラリによって提供される次のようなメソッドを使用します。

- `wrapping_*`、全てのモードをラップする。`wrapping_add`など。
- `checked_*`、オーバーフローが発生したら`None`を返す
- `overflowing_*`、オーバーフローが発生したらブール値を返す。
- `saturating_*`、値を最小値、最大値で飽和させる。

### 浮動小数点型

Rustには、浮動小数点数のプリミティブ型が2つあります。`f32, f64`です。デフォルトは`f64`で、全ての浮動小数点型は符号付きです。

```rust
let x = 2.0; // f64
let y: f32 = 3.0 // f32
```

浮動小数点は、IEEE-754標準に従って表されます。`f32`は単精度浮動小数点で、`f64`は倍精度浮動小数点です。

### 数値演算

Rustは、加算、減算、乗算、除算、余剰など、全ての数値型に期待される基本的な数学演算をサポートしています。整数除算は、最も近い整数に切り捨てます。

```rust
println!("addition: {}", 5 + 10);
println!("subtraction: {}", 95.5 - 4.3);
println!("multiplication: {}", 4 * 30);
println!("division: {}", 56.7 / 32.2);
println!("remainder: {}", 43 % 5);
```

算術演算子の詳細は、付録Bに含まれています。

### ブール型

Rustのブール型には、`true, false`の2つの値があります。ブール値のサイズは1バイトです。

```rust
println!("true is: {}", true);
println!("false is: {}", false);
```

ブール値の主な使用方法は、`if`文などです。

### キャラクタータイプ

Rustの`char`型は、言語で最も原始的なアルファベット型です。以下のように宣言します。

```rust
let c = '🥺';
println!("ぴえんは: {}", c);
```

`char`では、シングルクォート（`'`'）でリテラルを指定します。サイズは4バイトで、Unicodeスカラー値を表します。つまり、ASCIIだけでなく、より多くの値を表すことができます。アクセント文字、中国語、日本語、韓国語、絵文字など、ゼロ幅のスペースは全て有効な値です。

Unicodeスカラー値の範囲は`U+0000~U+D7FF`から`U+E000~U+10FFFF`までです。ただし文字は実際にはUnicodeの概念ではないため、文字が何であるかについての人間の直感とRustと一致しない場合があります。これは第8章で詳しく説明します。

### 複合タイプ

複合型は、複数の値を1つの型にグループ化できます。Rustには、タプルと配列という2つの基本的な複合型があります。

**タプル型**

タプルは、さまざまな型を持つ多数の値を1つの複合型にグループ化する一般的な方法です。タプルは固定長です。一度宣言すると、サイズを拡大、縮小することができなくなります。以下のように宣言します。

```rust
let tup: (i32, f64, u8) = (500, 6.4, 1);
```

タプルは単一の複合要素と見做されるため、変数はタプル全体にバインドされます。次のようにパターンマッチングを使用してタプル値を分解することができます。

```rust
let tup = (500, 6.4, 1);
let (x, y, z) = tup;
println!("The value of y is: {y}");
```

次のような書き方も可能です。

```rust
let x: (i32, f64, u8) = (500, 6.4, 1);
let five_hundred = x.0;
let six_point_four = x.1;
let one = x.2;
```

上記の例は変数`x`を作成し、それぞれのインデックスを使用してタプルの書くようにアクセスしています。

値のないタプルには、`unit`という特別な名前があります。この値とそれに対応する方の両方が書き込まれ、空の値または空の戻り値の方を表します。式は、他の値を返さない場合、ユニット値を暗黙的に返します。

**配列**