# データ型

> 参考：https://doc.rust-lang.org/book/ch03-02-data-types.html

Rustの全ての値は特定のデータ型であり、指定されているデータの種類をRustに伝え、そのデータの操作方法を認識しています。スカラーと複合の2つのデータ型サブセットを見ていきましょう。

Rustは制定機に型付けされた言語です。つまりコンパイル時に全ての変数の方を認識している必要があります。コンパイラは通常、値とその使用方法に基づいて使用する型を推測できます。

```rust
let guess: u32 = "42".parse().expect("Not a number!");
```

上記のコードで、`u32`を含めずにコンパイルした場合エラーになります。

```error
cargo run
   Compiling data_types v0.1.0 (/Users/ittoku/Documents/learning-rust/projects/data_types)
error[E0282]: type annotations needed
 --> src/main.rs:2:9
  |
2 |     let guess = "42".parse().expect("Not a number!");
  |         ^^^^^
  |
help: consider giving `guess` an explicit type
  |
2 |     let guess: _ = "42".parse().expect("Not a number!");
  |              +++

For more information about this error, try `rustc --explain E0282`.
error: could not compile `data_types` due to previous error
```

## スカラー型

スカラー型は単一の値を表します。Rustには、整数、浮動小数点数、ブール値、文字の4つの主要なスカラー型があります。これらがRustでどのように機能するか見ていきましょう。

### 整数型

整数は、少数部分のない数値です。上記の`u32`の型宣言は、32ビットのスペースを占める符号なし整数（符号付き整数型は`u`ではなく`i`から始まる）であることを示しています。

| Length  | Signed | Unsigned |
| ------- | ------ | -------- |
| 8-bit   | i8     | u8       |
| 16-bit  | i16    | u16      |
| 32-bit  | i32    | u32      |
| 64-bit  | i64    | u64      |
| 128-bit | i128   | u128     |
| arch    | isize  | usize    |

各バリアントは、`signed, unsigned`か、明示的なサイズを持ちます。符号付きと符号なしは、数値が負になる可能性があるかどうかを示します。つまり符号（`+`とか`-`とか）をつけるか（signed）、つけないか（unsigned）で決まります。ただし、数値が生であると想定しても安全な場合は、符号なしで表示されます。符号付き数値は、2の補数表現を使用して格納されます。

つまり符号付きと符号なしの表すことのできる数値は次のようになります。`size`は、`2**8-1`した数です。

| variant | size | range    |
| ------- | ---- | -------- |
| i8      | 255  | -128~127 |
| u8      | 255  | 0~255    |

さらに、`isize, usize`タイプは、プログラムが実行されているコンピュータのアーキテクチャによって異なります。64ビットアーキテクチャの場合は64ビット、32ビットアーキテクチャの場合は32ビットになります。

整数リテラルは、以下の表のように任意の形式で記述することができます。

| Number literals | Example     |
| --------------- | ----------- |
| Decimal         | 98_222      |
| Hex             | 0xff        |
| Octal           | 0o77        |
| Binary          | 0b1111_0000 |
| Byte (u8 only)  | b'A'        |

使用する型がよくわからない場合は、Rustのデフォルトから始めるのが一般的です。整数型のデフォルトは`i32`です。`isize, usize`を使用する主な状況は、ある種のコレクションにインデックスをつける場合です。

**整数オーバーフロー**

変数をその範囲外の値に変更しようとすると、整数オーバーフローが発生し、2つの動作のいずれかが発生する可能性があります。

デバッグモードでコンパイルする場合、Rustには整数オーバーフローのチェックが含まれており、この動作が発生すると実行時にプログラムがパニックに陥ります。Rustでは、プログラムがエラーで終了する時にパニックという用語を使用します。

リリースモードでコンパイルする場合、Rustには整数オーバーフローのチェックは含まれておらず、代わりにオーバーフローが発生した場合、Rustは2の補数ラッピングを実行します。つまり、型が保持できる最大値よりも大きい値は、型が保持できる最小値に「ラップアラウンド」します。つまり、型が`u8`の場合、256は0、257は1となります。

オーバーフローの可能性を明示的に処理するには、プリミティブ数値型の標準ライブラリによって提供される次のようなメソッドを使用します。

- `wrapping_*`、全てのモードをラップする。`wrapping_add`など。
- `checked_*`、オーバーフローが発生したら`None`を返す
- `overflowing_*`、オーバーフローが発生したらブール値を返す。
- `saturating_*`、値を最小値、最大値で飽和させる。

### 浮動小数点型

Rustには、浮動小数点数のプリミティブ型が2つあります。`f32, f64`です。デフォルトは`f64`で、全ての浮動小数点型は符号付きです。

```rust
let x = 2.0; // f64
let y: f32 = 3.0 // f32
```

浮動小数点は、IEEE-754標準に従って表されます。`f32`は単精度浮動小数点で、`f64`は倍精度浮動小数点です。

### 数値演算

Rustは、加算、減算、乗算、除算、余剰など、全ての数値型に期待される基本的な数学演算をサポートしています。整数除算は、最も近い整数に切り捨てます。

```rust
println!("addition: {}", 5 + 10);
println!("subtraction: {}", 95.5 - 4.3);
println!("multiplication: {}", 4 * 30);
println!("division: {}", 56.7 / 32.2);
println!("remainder: {}", 43 % 5);
```

算術演算子の詳細は、付録Bに含まれています。

### ブール型

Rustのブール型には、`true, false`の2つの値があります。ブール値のサイズは1バイトです。

```rust
println!("true is: {}", true);
println!("false is: {}", false);
```

ブール値の主な使用方法は、`if`文などです。

### キャラクタータイプ

Rustの`char`型は、言語で最も原始的なアルファベット型です。以下のように宣言します。

```rust
let c = '🥺';
println!("ぴえんは: {}", c);
```

`char`では、シングルクォート（`'`'）でリテラルを指定します。サイズは4バイトで、Unicodeスカラー値を表します。つまり、ASCIIだけでなく、より多くの値を表すことができます。アクセント文字、中国語、日本語、韓国語、絵文字など、ゼロ幅のスペースは全て有効な値です。

Unicodeスカラー値の範囲は`U+0000~U+D7FF`から`U+E000~U+10FFFF`までです。ただし文字は実際にはUnicodeの概念ではないため、文字が何であるかについての人間の直感とRustと一致しない場合があります。これは第8章で詳しく説明します。

### 複合タイプ

複合型は、複数の値を1つの型にグループ化できます。Rustには、タプルと配列という2つの基本的な複合型があります。

#### タプル型

タプルは、さまざまな型を持つ多数の値を1つの複合型にグループ化する一般的な方法です。タプルは固定長です。一度宣言すると、サイズを拡大、縮小することができなくなります。以下のように宣言します。

```rust
let tup: (i32, f64, u8) = (500, 6.4, 1);
```

タプルは単一の複合要素と見做されるため、変数はタプル全体にバインドされます。次のようにパターンマッチングを使用してタプル値を分解することができます。

```rust
let tup = (500, 6.4, 1);
let (x, y, z) = tup;
println!("The value of y is: {y}");
```

次のような書き方も可能です。

```rust
let x: (i32, f64, u8) = (500, 6.4, 1);
let five_hundred = x.0;
let six_point_four = x.1;
let one = x.2;
```

上記の例は変数`x`を作成し、それぞれのインデックスを使用してタプルの書くようにアクセスしています。

値のないタプルには、`unit`という特別な名前があります。この値とそれに対応する方の両方が書き込まれ、空の値または空の戻り値の方を表します。式は、他の値を返さない場合、ユニット値を暗黙的に返します。

#### 配列

配列は、複数の値のコレクションを持つ方法の1つです。タプルとは異なり、配列の全ての要素は同じ型でなくてななりません。また固定長です。

```rust
let a = [1, 2, 3, 4, 5];
```

配列は、データをヒープではなくスタックに割り当てたい場合、または要素の数を常に固定したい場合に便利です。ただし、ベクター型ほど柔軟ではありません。

ベクトルは、サイズの拡大、縮小が許可されている標準ライブラリによって提供されるコレクションタイプです。配列とベクトルのどちらを使用すべきかわからない場合は、ベクトルを使用する必要があります。

ただし、要素の数を変更する必要がないことがわかっている場合は、配列の方が便利です。以下の例の月の名前を使用している場合、ベクトルではなく配列を使用する方が良いです。

```rust
let months = ["January", "February", "March", "April", "May", "June", "July", "August", "September", "October", "November", "December"];
```

次のように書く要素の型、セミコロン、配列内の要素の数を含む括弧を使用して、配列の型を定義します。

```rust
let a: [i32; 5] = [1, 2, 3, 4, 5];
```

また、初期値、セミコロン、配列の長さを括弧で指定することで、各要素に同じ値を含むように定義することもできます。

```rust
let a = [3; 5]; // [3, 3, 3, 3, 3]
```

**配列要素へのアクセス**

配列は、スタックに割り当てることができる既知の固定サイズのメモリの単一のチャンクです。次のように、インデックスを使用して配列の要素にアクセスできます。

```rust
let a = [1, 2, 3, 4, 5];
let first = a[0];
let second = 1[1];
```

**無効な配列要素へのアクセス**

配列の末尾を超えた配列の要素にアクセスしようとするとどうなるでしょう。以下の例を参考に動きを見てみましょう。

```rust
use std::io;

fn main() {
    let a = [1, 2, 3, 4, 5];

    println!("Please enter an array index.");

    let mut index = String::new();

    io::stdin()
        .read_line(&mut index)
        .expect("Failed to read line");

    let index: usize = index
        .trim()
        .parse()
        .expect("Index entered was not a number");

    let element = a[index];

    println!("The value of the element at index {index} is: {element}");
}
```

このコードは正常にコンパイルされます。このコードを実行して、配列の末尾を超える数値を入力すると、次のような出力が表示されます。

```shell
thread 'main' panicked at 'index out of bounds: the len is 5 but the index is 5', src/main.rs:60:19
note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace
```

プログラムは、インデックス操作で無効な値を使用した時点で実行時エラーを引き起こしました。この場合Rustはパニックになります。

これは、Rustのメモリ安全原則が実際に適用されている例です。多くの低水準言語では、この種のチェックは行われておらず、不適切なインデックスを指定すると、無効なメモリにアクセスできます。Rustは、メモリアクセスを許可して続行するのではなく、すぐに終了することで、この種のエラーからユーザーを保護します。第9章では、Rustのエラー処理の詳細と、パニックにならず、無効なメモリアクセスを許可しない、読みやすく安全なコードを作成する方法について説明します。