# `match` Control Flowの構成

> 参考: https://doc.rust-lang.org/stable/book/ch06-02-match.html

Rustには`match`という強力な制御フロー構造があります。値を一連のパターンと比較して、どのパターンとマッチしたかに基づいてコードを実行することができます。
パターンはリテラル値、変数名、ワイルドカードなど、様々なもので構成できます。第18章では、様々な種類のパターンとその機能について説明します。
`match`の威力は、パターンの表現力とコンパイラが、すべての可能なケースが処理されていることを確認することから生まれます。

値はmatchの各パターンを通過し、値が最初のパターンで適合するコードブロックを実行します。

matchを使ったコインの例を見ていきましょう。以下のコードは、未知のアメリカ合衆国硬貨を受け取って、計数機と同じようにそれがどの硬貨かを判断してその値をセントで返す関数について書いています。

```rust
enum Coin {
    Penny,
    Nickel,
    Dime,
    Quarter,
}

fn value_in_cents(coin: Coin) -> u8 {
    match coin {
        Coin::Penny => 1,
        Coin::Nickel => 5,
        Coin::Dime => 10,
        Coin::Quarter => 25,
    }
}
```

上記の関数について説明します。まず、`match`キーワードに続いて、式をリストアップします。これは`if`で使用される式と似ていますが、大きな違いがあります。
`if`では、式は`bool`値を返す必要がありますが、ここでは任意の型を返すことができます。ここでは`Coin enum`型を返しています。

`match`では、パターンとコードの2つからできています。上記を例にすると、最初のパターンは`Coin::Penny`で、コードは`=>`演算子の後ろです。この場合のコードは値1だけです。各アームと次のアームはコンマで区切ります。

`match`式が実行されると、結果として得られる値を上から順番にパターンを比較します。
あるパターンが値に一致すれば、そのパターンに関連するコードが実行されます。マッチしなければ、次のパターンと比較します。上記のコードだと`match`は4つのアームを持っています。

各アームに関連するコードは式であり、一致するアームの式の結果の値は、一致する式全体に対して返される値です。

各アームが値を返すだけの短いコードであれば通常、括弧は使いません。アームで複数行のコードを実行したい場合は、括弧を使用する必要があります。

```rust
match coin {
    Coin::Penny => {
        println!("Lucky penny!");
        1
    }
    // --snip--
}
```

## 値にバインドされるパターン

`match`アームのもう1つの便利な機能は、パターンにマッチする値の部分にバインドできる点です。これは、`enum`のバリアントから値を抽出する方法です。

例として、`enum`を少し変更して、その内部にデータを保持するようにしてみましょう。
1999年から2008年まで、アメリカ合衆国は片面に50州それぞれの異なるデザインを施したクォーターを鋳造していました。他の硬貨には州のデザインはないので、クォーターだけがこの特別な価値を持っています。
これを、UsState値を内部に保存するためにQuarterバリアントを変更することで、この情報を列挙に追加できます。

```rust
#[derive(Debug)]
enum UsState {
    Alabama,
    Alaska,
    // --snip--
}

enum Coin {
    Penny,
    Nickel,
    Dime,
    Quarter(UsState),
}
```

例えば、ある友人が50州全てのクォーターを集めようとしているとします。小銭をコインの種類ごとに分類しながら、それぞれのクォーターに関連する州を当てはめて、もしその友人が持っていないものがあれば、コレクションに加えることができます。

下記のコードでは、バリアントである`Coin::Quarter`の値にマッチするパターンに`state`という変数を追加しています。`Coin::Quarter`がマッチすると、`state`変数はそのクォーターの`state`の値にバインドされ、コードが実行されます。

```rust
match coin {
    // --snip--
    Coin::Quarter(state) => {
        println!("State quarter from {:?}!", state);
        25
    }
}
```

`value_in_cents(Coin::Quarter(UsState::Alaska))`を呼び出すと、`Coin::Quarter(UsState::Alaska)`となります。この値を各マッチアームと比較すると、`Coin::Quarter(state)`に到達するまでマッチしません。

## `match`と`Option<T>`

前のセクションでは、`Option<T>`を使う時に`Some case`から内部の`T`値を取り出したいと言いました。コイン列挙型でやったように`match`を使って`Option<T>`を扱うこともできます。
コインを比較する代わりに`Option<T>`の変種を比較しますが、`match`式が動作する方法は変わりません。

例として、`Option<i32>`を受け取って、中に値があればその値に1を足し、なければNone値を返す関数を書きます。

```rust
fn plus_one(x: Option<i32>) -> Option<i32> {
    match x {
        None => None,
        Some(i) => Some(i + 1),
    }
}

let five = Some(5);
let six = plus_one(five);
let none = plus_one(None);
```

`plus_one`を詳しくみていきましょう。まずは`five`変数に`Option<T>`型の`Some(5)`を代入します。つぎに`six`変数に`plus_one(five)`を呼び出し、返り値の`Some(6)`を代入します。
なぜ`Some(6)`になるのかというと、`five`変数がパターンの`Some(i)`と一致したため、そのパターンのコードが実行されたためです。これは、`none`変数でも同じことが言えます。

`match`と`enum`の組み合わせは多くの場面で役に立ちます。Rustのコードではこのパターンをよく見かけます。`enum`に対して`match`し、変数にその中のデータをバインドし、それに基づいてコードを実行します。
初めはちょっと難しいですが、一度慣れると、全ての言語でこのパターンを使いたいと思うようになります。常にユーザーのお気に入りです！
