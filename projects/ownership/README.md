# 所有権

> 参考：https://doc.rust-lang.org/book/ch04-01-what-is-ownership.html

所有権は、Rustプログラムがメモリを管理する一連の規則です。全てのプログラムは、実行中にコンピュータのメモリを管理する必要があります。メモリを管理する方法には、プログラムの実行時に使用されなくなったメモリを定期的に探すガベージコレクションを使う方法と、プログラマーがメモリを明示的に割り当てて解放する方法があります。Rustはこれらのアプローチを取らず、コンパイラがチェックする一連のルールを使用して、所有権のシステムを通じて管理されます。いずれかの規則に違反すると、プログラムはコンパイルされません。所有権の機能にプログラム実行中に遅くするものはありません。

所有権は多くのプログラマーにとって新しい概念であるため、慣れるまでに時間がかかります。Rustと所有権システムのルールに慣れるほど、安全で効率的なコードを自然に開発することが容易になります。ぜひマスターしましょう！

所有権を理解すると、Rustをユニークにする機能を理解するための強固な基盤ができます。この章では、非常に一般的なデータ構造である文字列に焦点を当てたいいくつかの例を通して、所有権について学びます。

> **スタックとヒープ**
>
> 多くのプログラミング言語では、スタックとヒープについて頻繁に考える必要はありません。しかし、Rustのようなシステムプログラミング言語では、値がスタック上にあるかヒープ上にあるかによって、言語の動作や特定の決定を行う必要があるか、影響を受けます。所有権の部分については、この章の後半でスタックとヒープに関連して説明するので、準備として簡単に説明します。
>
> スタックとヒープはどちらも、実行時にコードで使用されるメモリの一部ですが、それらは異なる方法で構造化されています。スタックは、取得した順序で値を格納し、逆の順序で値を削除します。これは、後入先出しと呼ばれます。お皿の積み重ねで考えてみてください。お皿を追加するときは、それらの山の上におき、お皿が必要になれば、上から1つ取り出します。データの追加はスタックへのプッシュと呼ばれ、データの削除はスタックからのポップと呼ばれます。スタックに格納される全てのデータは、既知の固定サイズである必要があります。コンパイル時にサイズが不明なデータ、またはサイズが変更される可能性のあるデータは、代わりにヒープに格納する必要があります。
>
> ヒープはあまり整理されていません。ヒープにデータを配置するときは、一定量のスペースを要求します。メモリアロケータは、十分な大きさの空き領域をヒープ内で見つけ、使用中としてマークし、その場所のアドレスであるポインタを返します。このプロセスは、ヒープへの割り当てと呼ばれ、単に割り当てと省略されることもあります。ヒープへのポインターは既知の固定サイズであるため、ポインターをスタックに格納できますが、実際のデータが必要な場合は、ポインターを辿る必要があります。レストランに座っていると考えてください。入店時に人数を告げると、スタッフが空いているテーブルを見つけて案内してくれます。あなたのグループの誰かが遅れてきた場合、彼らはあなたがどこに座っていたかを尋ねます。
>
> スタックへのプッシュは、アロケーターが新しいデータを格納する場所を検索する必要がないため、ヒープに割り当てるよりも高速です。その場所は常にスタックの一番上にあります。アロケーターはまずデータを保持するのに十分な大きさのスペースを見つけてから、次の割り当てに備えて簿記を実行する必要があるためです。
>
> ヒープ内のデータのアクセスは、スタックにあるデータにアクセスするよりもポインタをたどるので遅くなります。現代のプロセッサは、メモリ内のジャンプが少ないほど高速です。例えば、レストランで多くのテーブルから注文を受ける給仕で考えてみましょう。一つのテーブルの注文を全部取ってから次のテーブルに移るのが最も効率的です。Aテーブルから注文を受け、Bテーブルから注文を受け、またAテーブルから注文を受け、またBテーブルから注文を受けるとなると、はるかに時間がかかります。同じようにプロセッサは、他のデータから遠い（ヒープ上にある）データよりも、近い（スタック上にある）データを扱う方が、より良い仕事ができるのです。
>
> コードから関数を呼び出すと、関数に渡される値（ヒープのデータへのポインターを含む）と、関数のローカル変数がスタックにプッシュされます。関数が終了すると、これらの値はスタックからポップされます。
>
> コードのどの部分がヒープのどのデータを使用しているかを追跡し、ヒープの重複データの量を最小限に抑え、スペースが不足しないようにヒープの未使用データをクリーンアップすることは、所有権が対処する問題です。所有権を理解すれば、スタックとヒープについてあまり考える必要はなくなりますが、所有権の主な目的は、ヒープデータを管理することと知っていれば、所有権がどのように機能するか説明するのに役立ちます。

## 所有規則

まず、所有権のルールを見てみましょう。重要なのでこれらのルールを念頭においてください。

- Rustの各値には*owner*がいます。
- *owner*は1度に1人しか存在できません。
- *owner*がスコープから出た場合、値は削除されます。

## 変数のスコープ

これから書くRustの例には、`main`関数を書きません。その方が簡潔になり、ボイラープレートコードではなく実際の詳細に集中できるからです。

所有権の最初の例として、いくつかの変数のスコープを見ていきます。スコープは、項目が有効なプログラム内の範囲のことです。

```rust
let s = "hello";
```

変数`s`は文字列リテラルを参照し、その文字列の値はプログラムのテキストにハードコードされています。この変数は宣言された時点から、現在のスコープが終了するまで有効です。下記は変数`s`が有効であることを示すコメントを含むプログラムです。

```rust
{                     // s is not valid here, it's not yet declared
    let s = "hello";  // s is valid from this point forward

    // do stuff with s
}                     // this scope is now over, and s is no loger valid
```

ここまでスコープと変数の有効期限の関係は、他のプログラミング言語と同じです。次はこれを理解した上で、`String`型をみていきしましょう。

## String型

所有権を説明するには、第3章のデータ型で取り上げたものよりも複雑なデータ型が必要です。第3章のデータ型では、サイズが既知で、スタックに格納でき、スコープが終了したらスタックからポップアップできるからです。また、コードの別の部分が別のスコープで同じ値を使用する必要がある場合、迅速かつ簡単にコピーして、新しい独立したインスタンスを作成できてしまうのも理由の1つです。今回はヒープに保存されるデータについてRustがどのようにデータをクリーンアップするタイミングを判断しているのかをみていきます。

ここでは、String型の所有権についてみていきます。String型は、標準なライブラリでもあり、あなたが作成するものでもあり、他の複雑なデータ型にも当てはまります。String型については第8章で詳しく説明します。

文字列の値がプログラムにハードコードされる文字列リテラルをみたと思います。文字列リテラルは便利ですが、テキストを使いたい全ての状況に適しているとは限りません。その理由に、不変であること、コードを書くときに全ての文字列の値が分かるとは限らない、があります。例えば、ユーザーの入力を受け取ってそれを保存する場合はどうでしょう。このような状況のために、Rustには2つ目の文字列型である`String`があります。この型はヒープ上に確保されたデータを管理するため、コンパイル時にはわからない量のテキストを格納することができます。`String`は`from`関数を使って文字列リテラルから以下のように作ることができます。

```rust
let s = String::from("hello");
```

`::`演算子を使用すると、`string_from`のような名前を使用するのではなく、特定の`from`関数を`String`型の下に名前空間化することができます。詳しくは第5章（メソッドの構文）、第7章（モジュールツリーの項目を参照するためのパス）で説明します。

```rust
let mut s = String::from("hello");

s.push_str(", world!");  // push_str() appends a literal to a String

println!("{}", s);  // This will print `hello, world!`
```

なぜStringは変異できるのに、リテラルはできないのでしょうか？その違いは、この2つの型がメモリをどう扱うかにあります。

## メモリとアロケーション
